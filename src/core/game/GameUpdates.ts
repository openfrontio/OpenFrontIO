// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.2
// source: src/core/game/GameUpdates.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "game";

export enum PlayerType {
  Bot = 0,
  Human = 1,
  FakeHuman = 2,
}

export function playerTypeFromJSON(object: any): PlayerType {
  switch (object) {
    case 0:
    case "Bot":
      return PlayerType.Bot;
    case 1:
    case "Human":
      return PlayerType.Human;
    case 2:
    case "FakeHuman":
      return PlayerType.FakeHuman;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum PlayerType",
      );
  }
}

export function playerTypeToJSON(object: PlayerType): string {
  switch (object) {
    case PlayerType.Bot:
      return "Bot";
    case PlayerType.Human:
      return "Human";
    case PlayerType.FakeHuman:
      return "FakeHuman";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum PlayerType",
      );
  }
}

export enum UnitType {
  TransportShip = 0,
  Warship = 1,
  Shell = 2,
  SAMMissile = 3,
  Port = 4,
  AtomBomb = 5,
  HydrogenBomb = 6,
  TradeShip = 7,
  MissileSilo = 8,
  DefensePost = 9,
  SAMLauncher = 10,
  City = 11,
  MIRV = 12,
  MIRVWarhead = 13,
  Train = 14,
  Factory = 15,
}

export function unitTypeFromJSON(object: any): UnitType {
  switch (object) {
    case 0:
    case "TransportShip":
      return UnitType.TransportShip;
    case 1:
    case "Warship":
      return UnitType.Warship;
    case 2:
    case "Shell":
      return UnitType.Shell;
    case 3:
    case "SAMMissile":
      return UnitType.SAMMissile;
    case 4:
    case "Port":
      return UnitType.Port;
    case 5:
    case "AtomBomb":
      return UnitType.AtomBomb;
    case 6:
    case "HydrogenBomb":
      return UnitType.HydrogenBomb;
    case 7:
    case "TradeShip":
      return UnitType.TradeShip;
    case 8:
    case "MissileSilo":
      return UnitType.MissileSilo;
    case 9:
    case "DefensePost":
      return UnitType.DefensePost;
    case 10:
    case "SAMLauncher":
      return UnitType.SAMLauncher;
    case 11:
    case "City":
      return UnitType.City;
    case 12:
    case "MIRV":
      return UnitType.MIRV;
    case 13:
    case "MIRVWarhead":
      return UnitType.MIRVWarhead;
    case 14:
    case "Train":
      return UnitType.Train;
    case 15:
    case "Factory":
      return UnitType.Factory;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum UnitType",
      );
  }
}

export function unitTypeToJSON(object: UnitType): string {
  switch (object) {
    case UnitType.TransportShip:
      return "TransportShip";
    case UnitType.Warship:
      return "Warship";
    case UnitType.Shell:
      return "Shell";
    case UnitType.SAMMissile:
      return "SAMMissile";
    case UnitType.Port:
      return "Port";
    case UnitType.AtomBomb:
      return "AtomBomb";
    case UnitType.HydrogenBomb:
      return "HydrogenBomb";
    case UnitType.TradeShip:
      return "TradeShip";
    case UnitType.MissileSilo:
      return "MissileSilo";
    case UnitType.DefensePost:
      return "DefensePost";
    case UnitType.SAMLauncher:
      return "SAMLauncher";
    case UnitType.City:
      return "City";
    case UnitType.MIRV:
      return "MIRV";
    case UnitType.MIRVWarhead:
      return "MIRVWarhead";
    case UnitType.Train:
      return "Train";
    case UnitType.Factory:
      return "Factory";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum UnitType",
      );
  }
}

export enum TrainType {
  Engine = 0,
  Carriage = 1,
}

export function trainTypeFromJSON(object: any): TrainType {
  switch (object) {
    case 0:
    case "Engine":
      return TrainType.Engine;
    case 1:
    case "Carriage":
      return TrainType.Carriage;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum TrainType",
      );
  }
}

export function trainTypeToJSON(object: TrainType): string {
  switch (object) {
    case TrainType.Engine:
      return "Engine";
    case TrainType.Carriage:
      return "Carriage";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum TrainType",
      );
  }
}

/** Enums */
export enum GameUpdateType {
  Tile = 0,
  Unit = 1,
  Player = 2,
  DisplayEvent = 3,
  DisplayChatEvent = 4,
  AllianceRequest = 5,
  AllianceRequestReply = 6,
  BrokeAlliance = 7,
  AllianceExpired = 8,
  AllianceExtension = 9,
  TargetPlayer = 10,
  Emoji = 11,
  Win = 12,
  Hash = 13,
  UnitIncoming = 14,
  BonusEvent = 15,
  RailroadEvent = 16,
  ConquestEvent = 17,
  EmbargoEvent = 18,
}

export function gameUpdateTypeFromJSON(object: any): GameUpdateType {
  switch (object) {
    case 0:
    case "Tile":
      return GameUpdateType.Tile;
    case 1:
    case "Unit":
      return GameUpdateType.Unit;
    case 2:
    case "Player":
      return GameUpdateType.Player;
    case 3:
    case "DisplayEvent":
      return GameUpdateType.DisplayEvent;
    case 4:
    case "DisplayChatEvent":
      return GameUpdateType.DisplayChatEvent;
    case 5:
    case "AllianceRequest":
      return GameUpdateType.AllianceRequest;
    case 6:
    case "AllianceRequestReply":
      return GameUpdateType.AllianceRequestReply;
    case 7:
    case "BrokeAlliance":
      return GameUpdateType.BrokeAlliance;
    case 8:
    case "AllianceExpired":
      return GameUpdateType.AllianceExpired;
    case 9:
    case "AllianceExtension":
      return GameUpdateType.AllianceExtension;
    case 10:
    case "TargetPlayer":
      return GameUpdateType.TargetPlayer;
    case 11:
    case "Emoji":
      return GameUpdateType.Emoji;
    case 12:
    case "Win":
      return GameUpdateType.Win;
    case 13:
    case "Hash":
      return GameUpdateType.Hash;
    case 14:
    case "UnitIncoming":
      return GameUpdateType.UnitIncoming;
    case 15:
    case "BonusEvent":
      return GameUpdateType.BonusEvent;
    case 16:
    case "RailroadEvent":
      return GameUpdateType.RailroadEvent;
    case 17:
    case "ConquestEvent":
      return GameUpdateType.ConquestEvent;
    case 18:
    case "EmbargoEvent":
      return GameUpdateType.EmbargoEvent;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum GameUpdateType",
      );
  }
}

export function gameUpdateTypeToJSON(object: GameUpdateType): string {
  switch (object) {
    case GameUpdateType.Tile:
      return "Tile";
    case GameUpdateType.Unit:
      return "Unit";
    case GameUpdateType.Player:
      return "Player";
    case GameUpdateType.DisplayEvent:
      return "DisplayEvent";
    case GameUpdateType.DisplayChatEvent:
      return "DisplayChatEvent";
    case GameUpdateType.AllianceRequest:
      return "AllianceRequest";
    case GameUpdateType.AllianceRequestReply:
      return "AllianceRequestReply";
    case GameUpdateType.BrokeAlliance:
      return "BrokeAlliance";
    case GameUpdateType.AllianceExpired:
      return "AllianceExpired";
    case GameUpdateType.AllianceExtension:
      return "AllianceExtension";
    case GameUpdateType.TargetPlayer:
      return "TargetPlayer";
    case GameUpdateType.Emoji:
      return "Emoji";
    case GameUpdateType.Win:
      return "Win";
    case GameUpdateType.Hash:
      return "Hash";
    case GameUpdateType.UnitIncoming:
      return "UnitIncoming";
    case GameUpdateType.BonusEvent:
      return "BonusEvent";
    case GameUpdateType.RailroadEvent:
      return "RailroadEvent";
    case GameUpdateType.ConquestEvent:
      return "ConquestEvent";
    case GameUpdateType.EmbargoEvent:
      return "EmbargoEvent";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum GameUpdateType",
      );
  }
}

export enum MessageType {
  messageTypeUnspecified = 0,
  ATTACK_FAILED = 1,
  ATTACK_CANCELLED = 2,
  ATTACK_REQUEST = 3,
  CONQUERED_PLAYER = 4,
  MIRV_INBOUND = 5,
  NUKE_INBOUND = 6,
  HYDROGEN_BOMB_INBOUND = 7,
  NAVAL_INVASION_INBOUND = 8,
  SAM_MISS = 9,
  SAM_HIT = 10,
  CAPTURED_ENEMY_UNIT = 11,
  UNIT_CAPTURED_BY_ENEMY = 12,
  UNIT_DESTROYED = 13,
  ALLIANCE_ACCEPTED = 14,
  ALLIANCE_REJECTED = 15,
  ALLIANCE_REQUEST = 16,
  ALLIANCE_BROKEN = 17,
  ALLIANCE_EXPIRED = 18,
  SENT_GOLD_TO_PLAYER = 19,
  RECEIVED_GOLD_FROM_PLAYER = 20,
  RECEIVED_GOLD_FROM_TRADE = 21,
  SENT_TROOPS_TO_PLAYER = 22,
  RECEIVED_TROOPS_FROM_PLAYER = 23,
  CHAT = 24,
  RENEW_ALLIANCE = 25,
}

export function messageTypeFromJSON(object: any): MessageType {
  switch (object) {
    case 0:
    case "messageTypeUnspecified":
      return MessageType.messageTypeUnspecified;
    case 1:
    case "ATTACK_FAILED":
      return MessageType.ATTACK_FAILED;
    case 2:
    case "ATTACK_CANCELLED":
      return MessageType.ATTACK_CANCELLED;
    case 3:
    case "ATTACK_REQUEST":
      return MessageType.ATTACK_REQUEST;
    case 4:
    case "CONQUERED_PLAYER":
      return MessageType.CONQUERED_PLAYER;
    case 5:
    case "MIRV_INBOUND":
      return MessageType.MIRV_INBOUND;
    case 6:
    case "NUKE_INBOUND":
      return MessageType.NUKE_INBOUND;
    case 7:
    case "HYDROGEN_BOMB_INBOUND":
      return MessageType.HYDROGEN_BOMB_INBOUND;
    case 8:
    case "NAVAL_INVASION_INBOUND":
      return MessageType.NAVAL_INVASION_INBOUND;
    case 9:
    case "SAM_MISS":
      return MessageType.SAM_MISS;
    case 10:
    case "SAM_HIT":
      return MessageType.SAM_HIT;
    case 11:
    case "CAPTURED_ENEMY_UNIT":
      return MessageType.CAPTURED_ENEMY_UNIT;
    case 12:
    case "UNIT_CAPTURED_BY_ENEMY":
      return MessageType.UNIT_CAPTURED_BY_ENEMY;
    case 13:
    case "UNIT_DESTROYED":
      return MessageType.UNIT_DESTROYED;
    case 14:
    case "ALLIANCE_ACCEPTED":
      return MessageType.ALLIANCE_ACCEPTED;
    case 15:
    case "ALLIANCE_REJECTED":
      return MessageType.ALLIANCE_REJECTED;
    case 16:
    case "ALLIANCE_REQUEST":
      return MessageType.ALLIANCE_REQUEST;
    case 17:
    case "ALLIANCE_BROKEN":
      return MessageType.ALLIANCE_BROKEN;
    case 18:
    case "ALLIANCE_EXPIRED":
      return MessageType.ALLIANCE_EXPIRED;
    case 19:
    case "SENT_GOLD_TO_PLAYER":
      return MessageType.SENT_GOLD_TO_PLAYER;
    case 20:
    case "RECEIVED_GOLD_FROM_PLAYER":
      return MessageType.RECEIVED_GOLD_FROM_PLAYER;
    case 21:
    case "RECEIVED_GOLD_FROM_TRADE":
      return MessageType.RECEIVED_GOLD_FROM_TRADE;
    case 22:
    case "SENT_TROOPS_TO_PLAYER":
      return MessageType.SENT_TROOPS_TO_PLAYER;
    case 23:
    case "RECEIVED_TROOPS_FROM_PLAYER":
      return MessageType.RECEIVED_TROOPS_FROM_PLAYER;
    case 24:
    case "CHAT":
      return MessageType.CHAT;
    case 25:
    case "RENEW_ALLIANCE":
      return MessageType.RENEW_ALLIANCE;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum MessageType",
      );
  }
}

export function messageTypeToJSON(object: MessageType): string {
  switch (object) {
    case MessageType.messageTypeUnspecified:
      return "messageTypeUnspecified";
    case MessageType.ATTACK_FAILED:
      return "ATTACK_FAILED";
    case MessageType.ATTACK_CANCELLED:
      return "ATTACK_CANCELLED";
    case MessageType.ATTACK_REQUEST:
      return "ATTACK_REQUEST";
    case MessageType.CONQUERED_PLAYER:
      return "CONQUERED_PLAYER";
    case MessageType.MIRV_INBOUND:
      return "MIRV_INBOUND";
    case MessageType.NUKE_INBOUND:
      return "NUKE_INBOUND";
    case MessageType.HYDROGEN_BOMB_INBOUND:
      return "HYDROGEN_BOMB_INBOUND";
    case MessageType.NAVAL_INVASION_INBOUND:
      return "NAVAL_INVASION_INBOUND";
    case MessageType.SAM_MISS:
      return "SAM_MISS";
    case MessageType.SAM_HIT:
      return "SAM_HIT";
    case MessageType.CAPTURED_ENEMY_UNIT:
      return "CAPTURED_ENEMY_UNIT";
    case MessageType.UNIT_CAPTURED_BY_ENEMY:
      return "UNIT_CAPTURED_BY_ENEMY";
    case MessageType.UNIT_DESTROYED:
      return "UNIT_DESTROYED";
    case MessageType.ALLIANCE_ACCEPTED:
      return "ALLIANCE_ACCEPTED";
    case MessageType.ALLIANCE_REJECTED:
      return "ALLIANCE_REJECTED";
    case MessageType.ALLIANCE_REQUEST:
      return "ALLIANCE_REQUEST";
    case MessageType.ALLIANCE_BROKEN:
      return "ALLIANCE_BROKEN";
    case MessageType.ALLIANCE_EXPIRED:
      return "ALLIANCE_EXPIRED";
    case MessageType.SENT_GOLD_TO_PLAYER:
      return "SENT_GOLD_TO_PLAYER";
    case MessageType.RECEIVED_GOLD_FROM_PLAYER:
      return "RECEIVED_GOLD_FROM_PLAYER";
    case MessageType.RECEIVED_GOLD_FROM_TRADE:
      return "RECEIVED_GOLD_FROM_TRADE";
    case MessageType.SENT_TROOPS_TO_PLAYER:
      return "SENT_TROOPS_TO_PLAYER";
    case MessageType.RECEIVED_TROOPS_FROM_PLAYER:
      return "RECEIVED_TROOPS_FROM_PLAYER";
    case MessageType.CHAT:
      return "CHAT";
    case MessageType.RENEW_ALLIANCE:
      return "RENEW_ALLIANCE";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum MessageType",
      );
  }
}

export enum MessageCategory {
  messageCategoryUnspecified = 0,
  ATTACK = 1,
  NUKE = 2,
  ALLIANCE = 3,
  TRADE = 4,
  CHAT_CATEGORY = 5,
}

export function messageCategoryFromJSON(object: any): MessageCategory {
  switch (object) {
    case 0:
    case "messageCategoryUnspecified":
      return MessageCategory.messageCategoryUnspecified;
    case 1:
    case "ATTACK":
      return MessageCategory.ATTACK;
    case 2:
    case "NUKE":
      return MessageCategory.NUKE;
    case 3:
    case "ALLIANCE":
      return MessageCategory.ALLIANCE;
    case 4:
    case "TRADE":
      return MessageCategory.TRADE;
    case 5:
    case "CHAT_CATEGORY":
      return MessageCategory.CHAT_CATEGORY;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum MessageCategory",
      );
  }
}

export function messageCategoryToJSON(object: MessageCategory): string {
  switch (object) {
    case MessageCategory.messageCategoryUnspecified:
      return "messageCategoryUnspecified";
    case MessageCategory.ATTACK:
      return "ATTACK";
    case MessageCategory.NUKE:
      return "NUKE";
    case MessageCategory.ALLIANCE:
      return "ALLIANCE";
    case MessageCategory.TRADE:
      return "TRADE";
    case MessageCategory.CHAT_CATEGORY:
      return "CHAT_CATEGORY";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum MessageCategory",
      );
  }
}

export enum RailType {
  vertical = 0,
  horizontal = 1,
  topLeft = 2,
  topRight = 3,
  bottomLeft = 4,
  bottomRight = 5,
}

export function railTypeFromJSON(object: any): RailType {
  switch (object) {
    case 0:
    case "vertical":
      return RailType.vertical;
    case 1:
    case "horizontal":
      return RailType.horizontal;
    case 2:
    case "topLeft":
      return RailType.topLeft;
    case 3:
    case "topRight":
      return RailType.topRight;
    case 4:
    case "bottomLeft":
      return RailType.bottomLeft;
    case 5:
    case "bottomRight":
      return RailType.bottomRight;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RailType",
      );
  }
}

export function railTypeToJSON(object: RailType): string {
  switch (object) {
    case RailType.vertical:
      return "vertical";
    case RailType.horizontal:
      return "horizontal";
    case RailType.topLeft:
      return "topLeft";
    case RailType.topRight:
      return "topRight";
    case RailType.bottomLeft:
      return "bottomLeft";
    case RailType.bottomRight:
      return "bottomRight";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum RailType",
      );
  }
}

export interface NameViewData {
  x: number;
  y: number;
  size: number;
}

export interface EmojiMessage {
  senderId: number;
  emoji: string;
  allPlayers?: boolean | undefined;
  recipientId?: number | undefined;
  createdAt: number;
}

/** Update messages */
export interface BonusEventUpdate {
  player: string;
  /** TileRef encoded as int64 */
  tile: number;
  gold: number;
  troops: number;
}

export interface RailTile {
  /** TileRef encoded as int64 */
  tile: number;
  railType: RailType;
}

export interface RailroadUpdate {
  isActive: boolean;
  railTiles: RailTile[];
}

export interface ConquestUpdate {
  conquerorId: number;
  conqueredId: number;
  gold: number;
}

export interface UnitUpdate {
  type: GameUpdateType;
  unitType: UnitType;
  troops: number;
  id: number;
  ownerId: number;
  lastOwnerId?: number | undefined;
  /** TileRef encoded as int64 */
  pos: number;
  /** TileRef encoded as int64 */
  lastPos: number;
  isActive: boolean;
  reachedTarget: boolean;
  retreating: boolean;
  targetable: boolean;
  markedForDeletion?: number | undefined;
  /** Only for trade ships */
  targetUnitId?: number | undefined;
  /** TileRef encoded as int64, only for nukes */
  targetTile?: number | undefined;
  health?: number | undefined;
  underConstruction?: boolean | undefined;
  missileTimerQueue: number[];
  level: number;
  hasTrainStation: boolean;
  /** Only for trains */
  trainType?: TrainType | undefined;
  /** Only for trains */
  loaded?: boolean | undefined;
}

export interface AttackUpdate {
  attackerId: number;
  targetId: number;
  troops: number;
  id: string;
  retreating: boolean;
}

export interface AllianceView {
  id: number;
  other: string;
  createdAt: number;
  expiresAt: number;
  hasExtensionRequest: boolean;
}

export interface PlayerUpdate {
  nameViewData?: NameViewData | undefined;
  clientId?: string | undefined;
  name: string;
  displayName: string;
  id: string;
  team?: string | undefined;
  smallId: number;
  playerType: PlayerType;
  isAlive: boolean;
  isDisconnected: boolean;
  tilesOwned: number;
  gold: number;
  troops: number;
  allies: number[];
  embargoes: string[];
  isTraitor: boolean;
  traitorRemainingTicks?: number | undefined;
  targets: number[];
  outgoingEmojis: EmojiMessage[];
  outgoingAttacks: AttackUpdate[];
  incomingAttacks: AttackUpdate[];
  outgoingAllianceRequests: string[];
  alliances: AllianceView[];
  hasSpawned: boolean;
  betrayals: number;
  lastDeleteUnitTick: number;
}

export interface AllianceRequestUpdate {
  requestorId: number;
  recipientId: number;
  createdAt: number;
}

export interface AllianceRequestReplyUpdate {
  request: AllianceRequestUpdate | undefined;
  accepted: boolean;
}

export interface BrokeAllianceUpdate {
  traitorId: number;
  betrayedId: number;
}

export interface AllianceExpiredUpdate {
  player1Id: number;
  player2Id: number;
}

export interface AllianceExtensionUpdate {
  playerId: string;
  allianceId: number;
}

export interface TargetPlayerUpdate {
  playerId: number;
  targetId: number;
}

export interface EmojiUpdate {
  emoji: EmojiMessage | undefined;
}

export interface DisplayMessageUpdate {
  message: string;
  messageType: MessageType;
  goldAmount?: number | undefined;
  playerId?: number | undefined;
  params: { [key: string]: string };
}

export interface DisplayMessageUpdate_ParamsEntry {
  key: string;
  value: string;
}

export interface DisplayChatMessageUpdate {
  key: string;
  category: string;
  target?: string | undefined;
  playerId?: number | undefined;
  isFrom: boolean;
  recipient: string;
}

export interface WinUpdate {
  winner: string;
  stats: string;
}

export interface HashUpdate {
  tick: number;
  hash: number;
}

export interface UnitIncomingUpdate {
  unitId: number;
  message: string;
  messageType: MessageType;
  playerId: number;
}

export interface EmbargoUpdate {
  event: EmbargoUpdate_EmbargoEvent;
  playerId: number;
  embargoedId: number;
}

export enum EmbargoUpdate_EmbargoEvent {
  start = 0,
  stop = 1,
}

export function embargoUpdate_EmbargoEventFromJSON(
  object: any,
): EmbargoUpdate_EmbargoEvent {
  switch (object) {
    case 0:
    case "start":
      return EmbargoUpdate_EmbargoEvent.start;
    case 1:
    case "stop":
      return EmbargoUpdate_EmbargoEvent.stop;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " +
          object +
          " for enum EmbargoUpdate_EmbargoEvent",
      );
  }
}

export function embargoUpdate_EmbargoEventToJSON(
  object: EmbargoUpdate_EmbargoEvent,
): string {
  switch (object) {
    case EmbargoUpdate_EmbargoEvent.start:
      return "start";
    case EmbargoUpdate_EmbargoEvent.stop:
      return "stop";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " +
          object +
          " for enum EmbargoUpdate_EmbargoEvent",
      );
  }
}

/** Main GameUpdate message using oneof for polymorphism */
export interface GameUpdate {
  type: GameUpdateType;
  unit?: UnitUpdate | undefined;
  player?: PlayerUpdate | undefined;
  allianceRequest?: AllianceRequestUpdate | undefined;
  allianceRequestReply?: AllianceRequestReplyUpdate | undefined;
  brokeAlliance?: BrokeAllianceUpdate | undefined;
  allianceExpired?: AllianceExpiredUpdate | undefined;
  displayMessage?: DisplayMessageUpdate | undefined;
  displayChatMessage?: DisplayChatMessageUpdate | undefined;
  targetPlayer?: TargetPlayerUpdate | undefined;
  emoji?: EmojiUpdate | undefined;
  win?: WinUpdate | undefined;
  hash?: HashUpdate | undefined;
  unitIncoming?: UnitIncomingUpdate | undefined;
  allianceExtension?: AllianceExtensionUpdate | undefined;
  bonusEvent?: BonusEventUpdate | undefined;
  railroad?: RailroadUpdate | undefined;
  conquest?: ConquestUpdate | undefined;
  embargo?: EmbargoUpdate | undefined;
}

export interface GameUpdates {
  type: GameUpdateType;
  updates: GameUpdate[];
}

export interface GameUpdateViewData {
  tick: number;
  updates: { [key: number]: GameUpdates };
  tileUpdates: number[];
  playerNameViewData: { [key: string]: NameViewData };
  tickExecutionDuration?: number | undefined;
}

export interface GameUpdateViewData_UpdatesEntry {
  key: number;
  value: GameUpdates | undefined;
}

export interface GameUpdateViewData_PlayerNameViewDataEntry {
  key: string;
  value: NameViewData | undefined;
}

export interface ErrorUpdate {
  errMsg: string;
  stack?: string | undefined;
}

function createBaseNameViewData(): NameViewData {
  return { x: 0, y: 0, size: 0 };
}

export const NameViewData: MessageFns<NameViewData> = {
  encode(
    message: NameViewData,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(8).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).int32(message.y);
    }
    if (message.size !== 0) {
      writer.uint32(24).int32(message.size);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NameViewData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNameViewData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.x = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.y = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.size = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NameViewData {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
    };
  },

  toJSON(message: NameViewData): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NameViewData>, I>>(
    base?: I,
  ): NameViewData {
    return NameViewData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NameViewData>, I>>(
    object: I,
  ): NameViewData {
    const message = createBaseNameViewData();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.size = object.size ?? 0;
    return message;
  },
};

function createBaseEmojiMessage(): EmojiMessage {
  return {
    senderId: 0,
    emoji: "",
    allPlayers: undefined,
    recipientId: undefined,
    createdAt: 0,
  };
}

export const EmojiMessage: MessageFns<EmojiMessage> = {
  encode(
    message: EmojiMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.senderId !== 0) {
      writer.uint32(8).int32(message.senderId);
    }
    if (message.emoji !== "") {
      writer.uint32(18).string(message.emoji);
    }
    if (message.allPlayers !== undefined) {
      writer.uint32(24).bool(message.allPlayers);
    }
    if (message.recipientId !== undefined) {
      writer.uint32(32).int32(message.recipientId);
    }
    if (message.createdAt !== 0) {
      writer.uint32(40).int32(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmojiMessage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmojiMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.senderId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.emoji = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.allPlayers = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.recipientId = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.createdAt = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmojiMessage {
    return {
      senderId: isSet(object.senderId) ? globalThis.Number(object.senderId) : 0,
      emoji: isSet(object.emoji) ? globalThis.String(object.emoji) : "",
      allPlayers: isSet(object.allPlayers)
        ? globalThis.Boolean(object.allPlayers)
        : undefined,
      recipientId: isSet(object.recipientId)
        ? globalThis.Number(object.recipientId)
        : undefined,
      createdAt: isSet(object.createdAt)
        ? globalThis.Number(object.createdAt)
        : 0,
    };
  },

  toJSON(message: EmojiMessage): unknown {
    const obj: any = {};
    if (message.senderId !== 0) {
      obj.senderId = Math.round(message.senderId);
    }
    if (message.emoji !== "") {
      obj.emoji = message.emoji;
    }
    if (message.allPlayers !== undefined) {
      obj.allPlayers = message.allPlayers;
    }
    if (message.recipientId !== undefined) {
      obj.recipientId = Math.round(message.recipientId);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmojiMessage>, I>>(
    base?: I,
  ): EmojiMessage {
    return EmojiMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmojiMessage>, I>>(
    object: I,
  ): EmojiMessage {
    const message = createBaseEmojiMessage();
    message.senderId = object.senderId ?? 0;
    message.emoji = object.emoji ?? "";
    message.allPlayers = object.allPlayers ?? undefined;
    message.recipientId = object.recipientId ?? undefined;
    message.createdAt = object.createdAt ?? 0;
    return message;
  },
};

function createBaseBonusEventUpdate(): BonusEventUpdate {
  return { player: "", tile: 0, gold: 0, troops: 0 };
}

export const BonusEventUpdate: MessageFns<BonusEventUpdate> = {
  encode(
    message: BonusEventUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.player !== "") {
      writer.uint32(10).string(message.player);
    }
    if (message.tile !== 0) {
      writer.uint32(16).int64(message.tile);
    }
    if (message.gold !== 0) {
      writer.uint32(24).int64(message.gold);
    }
    if (message.troops !== 0) {
      writer.uint32(32).int64(message.troops);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BonusEventUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBonusEventUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.player = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tile = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gold = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.troops = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BonusEventUpdate {
    return {
      player: isSet(object.player) ? globalThis.String(object.player) : "",
      tile: isSet(object.tile) ? globalThis.Number(object.tile) : 0,
      gold: isSet(object.gold) ? globalThis.Number(object.gold) : 0,
      troops: isSet(object.troops) ? globalThis.Number(object.troops) : 0,
    };
  },

  toJSON(message: BonusEventUpdate): unknown {
    const obj: any = {};
    if (message.player !== "") {
      obj.player = message.player;
    }
    if (message.tile !== 0) {
      obj.tile = Math.round(message.tile);
    }
    if (message.gold !== 0) {
      obj.gold = Math.round(message.gold);
    }
    if (message.troops !== 0) {
      obj.troops = Math.round(message.troops);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BonusEventUpdate>, I>>(
    base?: I,
  ): BonusEventUpdate {
    return BonusEventUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BonusEventUpdate>, I>>(
    object: I,
  ): BonusEventUpdate {
    const message = createBaseBonusEventUpdate();
    message.player = object.player ?? "";
    message.tile = object.tile ?? 0;
    message.gold = object.gold ?? 0;
    message.troops = object.troops ?? 0;
    return message;
  },
};

function createBaseRailTile(): RailTile {
  return { tile: 0, railType: 0 };
}

export const RailTile: MessageFns<RailTile> = {
  encode(
    message: RailTile,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.tile !== 0) {
      writer.uint32(8).int64(message.tile);
    }
    if (message.railType !== 0) {
      writer.uint32(16).int32(message.railType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RailTile {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRailTile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tile = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.railType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RailTile {
    return {
      tile: isSet(object.tile) ? globalThis.Number(object.tile) : 0,
      railType: isSet(object.railType) ? railTypeFromJSON(object.railType) : 0,
    };
  },

  toJSON(message: RailTile): unknown {
    const obj: any = {};
    if (message.tile !== 0) {
      obj.tile = Math.round(message.tile);
    }
    if (message.railType !== 0) {
      obj.railType = railTypeToJSON(message.railType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RailTile>, I>>(base?: I): RailTile {
    return RailTile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RailTile>, I>>(object: I): RailTile {
    const message = createBaseRailTile();
    message.tile = object.tile ?? 0;
    message.railType = object.railType ?? 0;
    return message;
  },
};

function createBaseRailroadUpdate(): RailroadUpdate {
  return { isActive: false, railTiles: [] };
}

export const RailroadUpdate: MessageFns<RailroadUpdate> = {
  encode(
    message: RailroadUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.isActive !== false) {
      writer.uint32(8).bool(message.isActive);
    }
    for (const v of message.railTiles) {
      RailTile.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RailroadUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRailroadUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.railTiles.push(RailTile.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RailroadUpdate {
    return {
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : false,
      railTiles: globalThis.Array.isArray(object?.railTiles)
        ? object.railTiles.map((e: any) => RailTile.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RailroadUpdate): unknown {
    const obj: any = {};
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.railTiles?.length) {
      obj.railTiles = message.railTiles.map((e) => RailTile.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RailroadUpdate>, I>>(
    base?: I,
  ): RailroadUpdate {
    return RailroadUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RailroadUpdate>, I>>(
    object: I,
  ): RailroadUpdate {
    const message = createBaseRailroadUpdate();
    message.isActive = object.isActive ?? false;
    message.railTiles =
      object.railTiles?.map((e) => RailTile.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConquestUpdate(): ConquestUpdate {
  return { conquerorId: 0, conqueredId: 0, gold: 0 };
}

export const ConquestUpdate: MessageFns<ConquestUpdate> = {
  encode(
    message: ConquestUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.conquerorId !== 0) {
      writer.uint32(8).int32(message.conquerorId);
    }
    if (message.conqueredId !== 0) {
      writer.uint32(16).int32(message.conqueredId);
    }
    if (message.gold !== 0) {
      writer.uint32(24).int64(message.gold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConquestUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConquestUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.conquerorId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.conqueredId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gold = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConquestUpdate {
    return {
      conquerorId: isSet(object.conquerorId)
        ? globalThis.Number(object.conquerorId)
        : 0,
      conqueredId: isSet(object.conqueredId)
        ? globalThis.Number(object.conqueredId)
        : 0,
      gold: isSet(object.gold) ? globalThis.Number(object.gold) : 0,
    };
  },

  toJSON(message: ConquestUpdate): unknown {
    const obj: any = {};
    if (message.conquerorId !== 0) {
      obj.conquerorId = Math.round(message.conquerorId);
    }
    if (message.conqueredId !== 0) {
      obj.conqueredId = Math.round(message.conqueredId);
    }
    if (message.gold !== 0) {
      obj.gold = Math.round(message.gold);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConquestUpdate>, I>>(
    base?: I,
  ): ConquestUpdate {
    return ConquestUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConquestUpdate>, I>>(
    object: I,
  ): ConquestUpdate {
    const message = createBaseConquestUpdate();
    message.conquerorId = object.conquerorId ?? 0;
    message.conqueredId = object.conqueredId ?? 0;
    message.gold = object.gold ?? 0;
    return message;
  },
};

function createBaseUnitUpdate(): UnitUpdate {
  return {
    type: 0,
    unitType: 0,
    troops: 0,
    id: 0,
    ownerId: 0,
    lastOwnerId: undefined,
    pos: 0,
    lastPos: 0,
    isActive: false,
    reachedTarget: false,
    retreating: false,
    targetable: false,
    markedForDeletion: undefined,
    targetUnitId: undefined,
    targetTile: undefined,
    health: undefined,
    underConstruction: undefined,
    missileTimerQueue: [],
    level: 0,
    hasTrainStation: false,
    trainType: undefined,
    loaded: undefined,
  };
}

export const UnitUpdate: MessageFns<UnitUpdate> = {
  encode(
    message: UnitUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(176).int32(message.type);
    }
    if (message.unitType !== 0) {
      writer.uint32(8).int32(message.unitType);
    }
    if (message.troops !== 0) {
      writer.uint32(16).int32(message.troops);
    }
    if (message.id !== 0) {
      writer.uint32(24).int32(message.id);
    }
    if (message.ownerId !== 0) {
      writer.uint32(32).int32(message.ownerId);
    }
    if (message.lastOwnerId !== undefined) {
      writer.uint32(40).int32(message.lastOwnerId);
    }
    if (message.pos !== 0) {
      writer.uint32(48).int64(message.pos);
    }
    if (message.lastPos !== 0) {
      writer.uint32(56).int64(message.lastPos);
    }
    if (message.isActive !== false) {
      writer.uint32(64).bool(message.isActive);
    }
    if (message.reachedTarget !== false) {
      writer.uint32(72).bool(message.reachedTarget);
    }
    if (message.retreating !== false) {
      writer.uint32(80).bool(message.retreating);
    }
    if (message.targetable !== false) {
      writer.uint32(88).bool(message.targetable);
    }
    if (message.markedForDeletion !== undefined) {
      writer.uint32(96).int32(message.markedForDeletion);
    }
    if (message.targetUnitId !== undefined) {
      writer.uint32(104).int32(message.targetUnitId);
    }
    if (message.targetTile !== undefined) {
      writer.uint32(112).int64(message.targetTile);
    }
    if (message.health !== undefined) {
      writer.uint32(120).int32(message.health);
    }
    if (message.underConstruction !== undefined) {
      writer.uint32(128).bool(message.underConstruction);
    }
    writer.uint32(138).fork();
    for (const v of message.missileTimerQueue) {
      writer.int32(v);
    }
    writer.join();
    if (message.level !== 0) {
      writer.uint32(144).int32(message.level);
    }
    if (message.hasTrainStation !== false) {
      writer.uint32(152).bool(message.hasTrainStation);
    }
    if (message.trainType !== undefined) {
      writer.uint32(160).int32(message.trainType);
    }
    if (message.loaded !== undefined) {
      writer.uint32(168).bool(message.loaded);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnitUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnitUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.unitType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.troops = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ownerId = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lastOwnerId = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.pos = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.lastPos = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.reachedTarget = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.retreating = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.targetable = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.markedForDeletion = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.targetUnitId = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.targetTile = longToNumber(reader.int64());
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.health = reader.int32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.underConstruction = reader.bool();
          continue;
        }
        case 17: {
          if (tag === 136) {
            message.missileTimerQueue.push(reader.int32());

            continue;
          }

          if (tag === 138) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.missileTimerQueue.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.level = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.hasTrainStation = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.trainType = reader.int32() as any;
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.loaded = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnitUpdate {
    return {
      type: isSet(object.type) ? gameUpdateTypeFromJSON(object.type) : 0,
      unitType: isSet(object.unitType) ? unitTypeFromJSON(object.unitType) : 0,
      troops: isSet(object.troops) ? globalThis.Number(object.troops) : 0,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      ownerId: isSet(object.ownerId) ? globalThis.Number(object.ownerId) : 0,
      lastOwnerId: isSet(object.lastOwnerId)
        ? globalThis.Number(object.lastOwnerId)
        : undefined,
      pos: isSet(object.pos) ? globalThis.Number(object.pos) : 0,
      lastPos: isSet(object.lastPos) ? globalThis.Number(object.lastPos) : 0,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : false,
      reachedTarget: isSet(object.reachedTarget)
        ? globalThis.Boolean(object.reachedTarget)
        : false,
      retreating: isSet(object.retreating)
        ? globalThis.Boolean(object.retreating)
        : false,
      targetable: isSet(object.targetable)
        ? globalThis.Boolean(object.targetable)
        : false,
      markedForDeletion: isSet(object.markedForDeletion)
        ? globalThis.Number(object.markedForDeletion)
        : undefined,
      targetUnitId: isSet(object.targetUnitId)
        ? globalThis.Number(object.targetUnitId)
        : undefined,
      targetTile: isSet(object.targetTile)
        ? globalThis.Number(object.targetTile)
        : undefined,
      health: isSet(object.health)
        ? globalThis.Number(object.health)
        : undefined,
      underConstruction: isSet(object.underConstruction)
        ? globalThis.Boolean(object.underConstruction)
        : undefined,
      missileTimerQueue: globalThis.Array.isArray(object?.missileTimerQueue)
        ? object.missileTimerQueue.map((e: any) => globalThis.Number(e))
        : [],
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      hasTrainStation: isSet(object.hasTrainStation)
        ? globalThis.Boolean(object.hasTrainStation)
        : false,
      trainType: isSet(object.trainType)
        ? trainTypeFromJSON(object.trainType)
        : undefined,
      loaded: isSet(object.loaded)
        ? globalThis.Boolean(object.loaded)
        : undefined,
    };
  },

  toJSON(message: UnitUpdate): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = gameUpdateTypeToJSON(message.type);
    }
    if (message.unitType !== 0) {
      obj.unitType = unitTypeToJSON(message.unitType);
    }
    if (message.troops !== 0) {
      obj.troops = Math.round(message.troops);
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.ownerId !== 0) {
      obj.ownerId = Math.round(message.ownerId);
    }
    if (message.lastOwnerId !== undefined) {
      obj.lastOwnerId = Math.round(message.lastOwnerId);
    }
    if (message.pos !== 0) {
      obj.pos = Math.round(message.pos);
    }
    if (message.lastPos !== 0) {
      obj.lastPos = Math.round(message.lastPos);
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.reachedTarget !== false) {
      obj.reachedTarget = message.reachedTarget;
    }
    if (message.retreating !== false) {
      obj.retreating = message.retreating;
    }
    if (message.targetable !== false) {
      obj.targetable = message.targetable;
    }
    if (message.markedForDeletion !== undefined) {
      obj.markedForDeletion = Math.round(message.markedForDeletion);
    }
    if (message.targetUnitId !== undefined) {
      obj.targetUnitId = Math.round(message.targetUnitId);
    }
    if (message.targetTile !== undefined) {
      obj.targetTile = Math.round(message.targetTile);
    }
    if (message.health !== undefined) {
      obj.health = Math.round(message.health);
    }
    if (message.underConstruction !== undefined) {
      obj.underConstruction = message.underConstruction;
    }
    if (message.missileTimerQueue?.length) {
      obj.missileTimerQueue = message.missileTimerQueue.map((e) =>
        Math.round(e),
      );
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.hasTrainStation !== false) {
      obj.hasTrainStation = message.hasTrainStation;
    }
    if (message.trainType !== undefined) {
      obj.trainType = trainTypeToJSON(message.trainType);
    }
    if (message.loaded !== undefined) {
      obj.loaded = message.loaded;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnitUpdate>, I>>(base?: I): UnitUpdate {
    return UnitUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnitUpdate>, I>>(
    object: I,
  ): UnitUpdate {
    const message = createBaseUnitUpdate();
    message.type = object.type ?? 0;
    message.unitType = object.unitType ?? 0;
    message.troops = object.troops ?? 0;
    message.id = object.id ?? 0;
    message.ownerId = object.ownerId ?? 0;
    message.lastOwnerId = object.lastOwnerId ?? undefined;
    message.pos = object.pos ?? 0;
    message.lastPos = object.lastPos ?? 0;
    message.isActive = object.isActive ?? false;
    message.reachedTarget = object.reachedTarget ?? false;
    message.retreating = object.retreating ?? false;
    message.targetable = object.targetable ?? false;
    message.markedForDeletion = object.markedForDeletion ?? undefined;
    message.targetUnitId = object.targetUnitId ?? undefined;
    message.targetTile = object.targetTile ?? undefined;
    message.health = object.health ?? undefined;
    message.underConstruction = object.underConstruction ?? undefined;
    message.missileTimerQueue = object.missileTimerQueue?.map((e) => e) || [];
    message.level = object.level ?? 0;
    message.hasTrainStation = object.hasTrainStation ?? false;
    message.trainType = object.trainType ?? undefined;
    message.loaded = object.loaded ?? undefined;
    return message;
  },
};

function createBaseAttackUpdate(): AttackUpdate {
  return { attackerId: 0, targetId: 0, troops: 0, id: "", retreating: false };
}

export const AttackUpdate: MessageFns<AttackUpdate> = {
  encode(
    message: AttackUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.attackerId !== 0) {
      writer.uint32(8).int32(message.attackerId);
    }
    if (message.targetId !== 0) {
      writer.uint32(16).int32(message.targetId);
    }
    if (message.troops !== 0) {
      writer.uint32(24).int32(message.troops);
    }
    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }
    if (message.retreating !== false) {
      writer.uint32(40).bool(message.retreating);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttackUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttackUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.attackerId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.targetId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.troops = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.retreating = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttackUpdate {
    return {
      attackerId: isSet(object.attackerId)
        ? globalThis.Number(object.attackerId)
        : 0,
      targetId: isSet(object.targetId) ? globalThis.Number(object.targetId) : 0,
      troops: isSet(object.troops) ? globalThis.Number(object.troops) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      retreating: isSet(object.retreating)
        ? globalThis.Boolean(object.retreating)
        : false,
    };
  },

  toJSON(message: AttackUpdate): unknown {
    const obj: any = {};
    if (message.attackerId !== 0) {
      obj.attackerId = Math.round(message.attackerId);
    }
    if (message.targetId !== 0) {
      obj.targetId = Math.round(message.targetId);
    }
    if (message.troops !== 0) {
      obj.troops = Math.round(message.troops);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.retreating !== false) {
      obj.retreating = message.retreating;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttackUpdate>, I>>(
    base?: I,
  ): AttackUpdate {
    return AttackUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttackUpdate>, I>>(
    object: I,
  ): AttackUpdate {
    const message = createBaseAttackUpdate();
    message.attackerId = object.attackerId ?? 0;
    message.targetId = object.targetId ?? 0;
    message.troops = object.troops ?? 0;
    message.id = object.id ?? "";
    message.retreating = object.retreating ?? false;
    return message;
  },
};

function createBaseAllianceView(): AllianceView {
  return {
    id: 0,
    other: "",
    createdAt: 0,
    expiresAt: 0,
    hasExtensionRequest: false,
  };
}

export const AllianceView: MessageFns<AllianceView> = {
  encode(
    message: AllianceView,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.other !== "") {
      writer.uint32(18).string(message.other);
    }
    if (message.createdAt !== 0) {
      writer.uint32(24).int32(message.createdAt);
    }
    if (message.expiresAt !== 0) {
      writer.uint32(32).int32(message.expiresAt);
    }
    if (message.hasExtensionRequest !== false) {
      writer.uint32(40).bool(message.hasExtensionRequest);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllianceView {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllianceView();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.other = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.createdAt = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expiresAt = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.hasExtensionRequest = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllianceView {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      other: isSet(object.other) ? globalThis.String(object.other) : "",
      createdAt: isSet(object.createdAt)
        ? globalThis.Number(object.createdAt)
        : 0,
      expiresAt: isSet(object.expiresAt)
        ? globalThis.Number(object.expiresAt)
        : 0,
      hasExtensionRequest: isSet(object.hasExtensionRequest)
        ? globalThis.Boolean(object.hasExtensionRequest)
        : false,
    };
  },

  toJSON(message: AllianceView): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.other !== "") {
      obj.other = message.other;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.expiresAt !== 0) {
      obj.expiresAt = Math.round(message.expiresAt);
    }
    if (message.hasExtensionRequest !== false) {
      obj.hasExtensionRequest = message.hasExtensionRequest;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllianceView>, I>>(
    base?: I,
  ): AllianceView {
    return AllianceView.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllianceView>, I>>(
    object: I,
  ): AllianceView {
    const message = createBaseAllianceView();
    message.id = object.id ?? 0;
    message.other = object.other ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.expiresAt = object.expiresAt ?? 0;
    message.hasExtensionRequest = object.hasExtensionRequest ?? false;
    return message;
  },
};

function createBasePlayerUpdate(): PlayerUpdate {
  return {
    nameViewData: undefined,
    clientId: undefined,
    name: "",
    displayName: "",
    id: "",
    team: undefined,
    smallId: 0,
    playerType: 0,
    isAlive: false,
    isDisconnected: false,
    tilesOwned: 0,
    gold: 0,
    troops: 0,
    allies: [],
    embargoes: [],
    isTraitor: false,
    traitorRemainingTicks: undefined,
    targets: [],
    outgoingEmojis: [],
    outgoingAttacks: [],
    incomingAttacks: [],
    outgoingAllianceRequests: [],
    alliances: [],
    hasSpawned: false,
    betrayals: 0,
    lastDeleteUnitTick: 0,
  };
}

export const PlayerUpdate: MessageFns<PlayerUpdate> = {
  encode(
    message: PlayerUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.nameViewData !== undefined) {
      NameViewData.encode(
        message.nameViewData,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.clientId !== undefined) {
      writer.uint32(18).string(message.clientId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.id !== "") {
      writer.uint32(42).string(message.id);
    }
    if (message.team !== undefined) {
      writer.uint32(50).string(message.team);
    }
    if (message.smallId !== 0) {
      writer.uint32(56).int32(message.smallId);
    }
    if (message.playerType !== 0) {
      writer.uint32(64).int32(message.playerType);
    }
    if (message.isAlive !== false) {
      writer.uint32(72).bool(message.isAlive);
    }
    if (message.isDisconnected !== false) {
      writer.uint32(80).bool(message.isDisconnected);
    }
    if (message.tilesOwned !== 0) {
      writer.uint32(88).int32(message.tilesOwned);
    }
    if (message.gold !== 0) {
      writer.uint32(96).uint64(message.gold);
    }
    if (message.troops !== 0) {
      writer.uint32(104).int32(message.troops);
    }
    writer.uint32(114).fork();
    for (const v of message.allies) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.embargoes) {
      writer.uint32(122).string(v!);
    }
    if (message.isTraitor !== false) {
      writer.uint32(128).bool(message.isTraitor);
    }
    if (message.traitorRemainingTicks !== undefined) {
      writer.uint32(136).int32(message.traitorRemainingTicks);
    }
    writer.uint32(146).fork();
    for (const v of message.targets) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.outgoingEmojis) {
      EmojiMessage.encode(v!, writer.uint32(154).fork()).join();
    }
    for (const v of message.outgoingAttacks) {
      AttackUpdate.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.incomingAttacks) {
      AttackUpdate.encode(v!, writer.uint32(170).fork()).join();
    }
    for (const v of message.outgoingAllianceRequests) {
      writer.uint32(178).string(v!);
    }
    for (const v of message.alliances) {
      AllianceView.encode(v!, writer.uint32(186).fork()).join();
    }
    if (message.hasSpawned !== false) {
      writer.uint32(192).bool(message.hasSpawned);
    }
    if (message.betrayals !== 0) {
      writer.uint32(200).int32(message.betrayals);
    }
    if (message.lastDeleteUnitTick !== 0) {
      writer.uint32(208).int32(message.lastDeleteUnitTick);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nameViewData = NameViewData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.team = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.smallId = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.playerType = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isAlive = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isDisconnected = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.tilesOwned = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.gold = longToNumber(reader.uint64());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.troops = reader.int32();
          continue;
        }
        case 14: {
          if (tag === 112) {
            message.allies.push(reader.int32());

            continue;
          }

          if (tag === 114) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allies.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.embargoes.push(reader.string());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.isTraitor = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.traitorRemainingTicks = reader.int32();
          continue;
        }
        case 18: {
          if (tag === 144) {
            message.targets.push(reader.int32());

            continue;
          }

          if (tag === 146) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.targets.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.outgoingEmojis.push(
            EmojiMessage.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.outgoingAttacks.push(
            AttackUpdate.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.incomingAttacks.push(
            AttackUpdate.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.outgoingAllianceRequests.push(reader.string());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.alliances.push(AllianceView.decode(reader, reader.uint32()));
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.hasSpawned = reader.bool();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.betrayals = reader.int32();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.lastDeleteUnitTick = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerUpdate {
    return {
      nameViewData: isSet(object.nameViewData)
        ? NameViewData.fromJSON(object.nameViewData)
        : undefined,
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName)
        ? globalThis.String(object.displayName)
        : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      team: isSet(object.team) ? globalThis.String(object.team) : undefined,
      smallId: isSet(object.smallId) ? globalThis.Number(object.smallId) : 0,
      playerType: isSet(object.playerType)
        ? playerTypeFromJSON(object.playerType)
        : 0,
      isAlive: isSet(object.isAlive)
        ? globalThis.Boolean(object.isAlive)
        : false,
      isDisconnected: isSet(object.isDisconnected)
        ? globalThis.Boolean(object.isDisconnected)
        : false,
      tilesOwned: isSet(object.tilesOwned)
        ? globalThis.Number(object.tilesOwned)
        : 0,
      gold: isSet(object.gold) ? globalThis.Number(object.gold) : 0,
      troops: isSet(object.troops) ? globalThis.Number(object.troops) : 0,
      allies: globalThis.Array.isArray(object?.allies)
        ? object.allies.map((e: any) => globalThis.Number(e))
        : [],
      embargoes: globalThis.Array.isArray(object?.embargoes)
        ? object.embargoes.map((e: any) => globalThis.String(e))
        : [],
      isTraitor: isSet(object.isTraitor)
        ? globalThis.Boolean(object.isTraitor)
        : false,
      traitorRemainingTicks: isSet(object.traitorRemainingTicks)
        ? globalThis.Number(object.traitorRemainingTicks)
        : undefined,
      targets: globalThis.Array.isArray(object?.targets)
        ? object.targets.map((e: any) => globalThis.Number(e))
        : [],
      outgoingEmojis: globalThis.Array.isArray(object?.outgoingEmojis)
        ? object.outgoingEmojis.map((e: any) => EmojiMessage.fromJSON(e))
        : [],
      outgoingAttacks: globalThis.Array.isArray(object?.outgoingAttacks)
        ? object.outgoingAttacks.map((e: any) => AttackUpdate.fromJSON(e))
        : [],
      incomingAttacks: globalThis.Array.isArray(object?.incomingAttacks)
        ? object.incomingAttacks.map((e: any) => AttackUpdate.fromJSON(e))
        : [],
      outgoingAllianceRequests: globalThis.Array.isArray(
        object?.outgoingAllianceRequests,
      )
        ? object.outgoingAllianceRequests.map((e: any) => globalThis.String(e))
        : [],
      alliances: globalThis.Array.isArray(object?.alliances)
        ? object.alliances.map((e: any) => AllianceView.fromJSON(e))
        : [],
      hasSpawned: isSet(object.hasSpawned)
        ? globalThis.Boolean(object.hasSpawned)
        : false,
      betrayals: isSet(object.betrayals)
        ? globalThis.Number(object.betrayals)
        : 0,
      lastDeleteUnitTick: isSet(object.lastDeleteUnitTick)
        ? globalThis.Number(object.lastDeleteUnitTick)
        : 0,
    };
  },

  toJSON(message: PlayerUpdate): unknown {
    const obj: any = {};
    if (message.nameViewData !== undefined) {
      obj.nameViewData = NameViewData.toJSON(message.nameViewData);
    }
    if (message.clientId !== undefined) {
      obj.clientId = message.clientId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.team !== undefined) {
      obj.team = message.team;
    }
    if (message.smallId !== 0) {
      obj.smallId = Math.round(message.smallId);
    }
    if (message.playerType !== 0) {
      obj.playerType = playerTypeToJSON(message.playerType);
    }
    if (message.isAlive !== false) {
      obj.isAlive = message.isAlive;
    }
    if (message.isDisconnected !== false) {
      obj.isDisconnected = message.isDisconnected;
    }
    if (message.tilesOwned !== 0) {
      obj.tilesOwned = Math.round(message.tilesOwned);
    }
    if (message.gold !== 0) {
      obj.gold = Math.round(message.gold);
    }
    if (message.troops !== 0) {
      obj.troops = Math.round(message.troops);
    }
    if (message.allies?.length) {
      obj.allies = message.allies.map((e) => Math.round(e));
    }
    if (message.embargoes?.length) {
      obj.embargoes = message.embargoes;
    }
    if (message.isTraitor !== false) {
      obj.isTraitor = message.isTraitor;
    }
    if (message.traitorRemainingTicks !== undefined) {
      obj.traitorRemainingTicks = Math.round(message.traitorRemainingTicks);
    }
    if (message.targets?.length) {
      obj.targets = message.targets.map((e) => Math.round(e));
    }
    if (message.outgoingEmojis?.length) {
      obj.outgoingEmojis = message.outgoingEmojis.map((e) =>
        EmojiMessage.toJSON(e),
      );
    }
    if (message.outgoingAttacks?.length) {
      obj.outgoingAttacks = message.outgoingAttacks.map((e) =>
        AttackUpdate.toJSON(e),
      );
    }
    if (message.incomingAttacks?.length) {
      obj.incomingAttacks = message.incomingAttacks.map((e) =>
        AttackUpdate.toJSON(e),
      );
    }
    if (message.outgoingAllianceRequests?.length) {
      obj.outgoingAllianceRequests = message.outgoingAllianceRequests;
    }
    if (message.alliances?.length) {
      obj.alliances = message.alliances.map((e) => AllianceView.toJSON(e));
    }
    if (message.hasSpawned !== false) {
      obj.hasSpawned = message.hasSpawned;
    }
    if (message.betrayals !== 0) {
      obj.betrayals = Math.round(message.betrayals);
    }
    if (message.lastDeleteUnitTick !== 0) {
      obj.lastDeleteUnitTick = Math.round(message.lastDeleteUnitTick);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerUpdate>, I>>(
    base?: I,
  ): PlayerUpdate {
    return PlayerUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerUpdate>, I>>(
    object: I,
  ): PlayerUpdate {
    const message = createBasePlayerUpdate();
    message.nameViewData =
      object.nameViewData !== undefined && object.nameViewData !== null
        ? NameViewData.fromPartial(object.nameViewData)
        : undefined;
    message.clientId = object.clientId ?? undefined;
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.id = object.id ?? "";
    message.team = object.team ?? undefined;
    message.smallId = object.smallId ?? 0;
    message.playerType = object.playerType ?? 0;
    message.isAlive = object.isAlive ?? false;
    message.isDisconnected = object.isDisconnected ?? false;
    message.tilesOwned = object.tilesOwned ?? 0;
    message.gold = object.gold ?? 0;
    message.troops = object.troops ?? 0;
    message.allies = object.allies?.map((e) => e) || [];
    message.embargoes = object.embargoes?.map((e) => e) || [];
    message.isTraitor = object.isTraitor ?? false;
    message.traitorRemainingTicks = object.traitorRemainingTicks ?? undefined;
    message.targets = object.targets?.map((e) => e) || [];
    message.outgoingEmojis =
      object.outgoingEmojis?.map((e) => EmojiMessage.fromPartial(e)) || [];
    message.outgoingAttacks =
      object.outgoingAttacks?.map((e) => AttackUpdate.fromPartial(e)) || [];
    message.incomingAttacks =
      object.incomingAttacks?.map((e) => AttackUpdate.fromPartial(e)) || [];
    message.outgoingAllianceRequests =
      object.outgoingAllianceRequests?.map((e) => e) || [];
    message.alliances =
      object.alliances?.map((e) => AllianceView.fromPartial(e)) || [];
    message.hasSpawned = object.hasSpawned ?? false;
    message.betrayals = object.betrayals ?? 0;
    message.lastDeleteUnitTick = object.lastDeleteUnitTick ?? 0;
    return message;
  },
};

function createBaseAllianceRequestUpdate(): AllianceRequestUpdate {
  return { requestorId: 0, recipientId: 0, createdAt: 0 };
}

export const AllianceRequestUpdate: MessageFns<AllianceRequestUpdate> = {
  encode(
    message: AllianceRequestUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.requestorId !== 0) {
      writer.uint32(8).int32(message.requestorId);
    }
    if (message.recipientId !== 0) {
      writer.uint32(16).int32(message.recipientId);
    }
    if (message.createdAt !== 0) {
      writer.uint32(24).int32(message.createdAt);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AllianceRequestUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllianceRequestUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.requestorId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.recipientId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.createdAt = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllianceRequestUpdate {
    return {
      requestorId: isSet(object.requestorId)
        ? globalThis.Number(object.requestorId)
        : 0,
      recipientId: isSet(object.recipientId)
        ? globalThis.Number(object.recipientId)
        : 0,
      createdAt: isSet(object.createdAt)
        ? globalThis.Number(object.createdAt)
        : 0,
    };
  },

  toJSON(message: AllianceRequestUpdate): unknown {
    const obj: any = {};
    if (message.requestorId !== 0) {
      obj.requestorId = Math.round(message.requestorId);
    }
    if (message.recipientId !== 0) {
      obj.recipientId = Math.round(message.recipientId);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllianceRequestUpdate>, I>>(
    base?: I,
  ): AllianceRequestUpdate {
    return AllianceRequestUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllianceRequestUpdate>, I>>(
    object: I,
  ): AllianceRequestUpdate {
    const message = createBaseAllianceRequestUpdate();
    message.requestorId = object.requestorId ?? 0;
    message.recipientId = object.recipientId ?? 0;
    message.createdAt = object.createdAt ?? 0;
    return message;
  },
};

function createBaseAllianceRequestReplyUpdate(): AllianceRequestReplyUpdate {
  return { request: undefined, accepted: false };
}

export const AllianceRequestReplyUpdate: MessageFns<AllianceRequestReplyUpdate> =
  {
    encode(
      message: AllianceRequestReplyUpdate,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.request !== undefined) {
        AllianceRequestUpdate.encode(
          message.request,
          writer.uint32(10).fork(),
        ).join();
      }
      if (message.accepted !== false) {
        writer.uint32(16).bool(message.accepted);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): AllianceRequestReplyUpdate {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseAllianceRequestReplyUpdate();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.request = AllianceRequestUpdate.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.accepted = reader.bool();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): AllianceRequestReplyUpdate {
      return {
        request: isSet(object.request)
          ? AllianceRequestUpdate.fromJSON(object.request)
          : undefined,
        accepted: isSet(object.accepted)
          ? globalThis.Boolean(object.accepted)
          : false,
      };
    },

    toJSON(message: AllianceRequestReplyUpdate): unknown {
      const obj: any = {};
      if (message.request !== undefined) {
        obj.request = AllianceRequestUpdate.toJSON(message.request);
      }
      if (message.accepted !== false) {
        obj.accepted = message.accepted;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<AllianceRequestReplyUpdate>, I>>(
      base?: I,
    ): AllianceRequestReplyUpdate {
      return AllianceRequestReplyUpdate.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<AllianceRequestReplyUpdate>, I>>(
      object: I,
    ): AllianceRequestReplyUpdate {
      const message = createBaseAllianceRequestReplyUpdate();
      message.request =
        object.request !== undefined && object.request !== null
          ? AllianceRequestUpdate.fromPartial(object.request)
          : undefined;
      message.accepted = object.accepted ?? false;
      return message;
    },
  };

function createBaseBrokeAllianceUpdate(): BrokeAllianceUpdate {
  return { traitorId: 0, betrayedId: 0 };
}

export const BrokeAllianceUpdate: MessageFns<BrokeAllianceUpdate> = {
  encode(
    message: BrokeAllianceUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.traitorId !== 0) {
      writer.uint32(8).int32(message.traitorId);
    }
    if (message.betrayedId !== 0) {
      writer.uint32(16).int32(message.betrayedId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): BrokeAllianceUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrokeAllianceUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.traitorId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.betrayedId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrokeAllianceUpdate {
    return {
      traitorId: isSet(object.traitorId)
        ? globalThis.Number(object.traitorId)
        : 0,
      betrayedId: isSet(object.betrayedId)
        ? globalThis.Number(object.betrayedId)
        : 0,
    };
  },

  toJSON(message: BrokeAllianceUpdate): unknown {
    const obj: any = {};
    if (message.traitorId !== 0) {
      obj.traitorId = Math.round(message.traitorId);
    }
    if (message.betrayedId !== 0) {
      obj.betrayedId = Math.round(message.betrayedId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BrokeAllianceUpdate>, I>>(
    base?: I,
  ): BrokeAllianceUpdate {
    return BrokeAllianceUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BrokeAllianceUpdate>, I>>(
    object: I,
  ): BrokeAllianceUpdate {
    const message = createBaseBrokeAllianceUpdate();
    message.traitorId = object.traitorId ?? 0;
    message.betrayedId = object.betrayedId ?? 0;
    return message;
  },
};

function createBaseAllianceExpiredUpdate(): AllianceExpiredUpdate {
  return { player1Id: 0, player2Id: 0 };
}

export const AllianceExpiredUpdate: MessageFns<AllianceExpiredUpdate> = {
  encode(
    message: AllianceExpiredUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.player1Id !== 0) {
      writer.uint32(8).int32(message.player1Id);
    }
    if (message.player2Id !== 0) {
      writer.uint32(16).int32(message.player2Id);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AllianceExpiredUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllianceExpiredUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.player1Id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.player2Id = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllianceExpiredUpdate {
    return {
      player1Id: isSet(object.player1Id)
        ? globalThis.Number(object.player1Id)
        : 0,
      player2Id: isSet(object.player2Id)
        ? globalThis.Number(object.player2Id)
        : 0,
    };
  },

  toJSON(message: AllianceExpiredUpdate): unknown {
    const obj: any = {};
    if (message.player1Id !== 0) {
      obj.player1Id = Math.round(message.player1Id);
    }
    if (message.player2Id !== 0) {
      obj.player2Id = Math.round(message.player2Id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllianceExpiredUpdate>, I>>(
    base?: I,
  ): AllianceExpiredUpdate {
    return AllianceExpiredUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllianceExpiredUpdate>, I>>(
    object: I,
  ): AllianceExpiredUpdate {
    const message = createBaseAllianceExpiredUpdate();
    message.player1Id = object.player1Id ?? 0;
    message.player2Id = object.player2Id ?? 0;
    return message;
  },
};

function createBaseAllianceExtensionUpdate(): AllianceExtensionUpdate {
  return { playerId: "", allianceId: 0 };
}

export const AllianceExtensionUpdate: MessageFns<AllianceExtensionUpdate> = {
  encode(
    message: AllianceExtensionUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.playerId !== "") {
      writer.uint32(10).string(message.playerId);
    }
    if (message.allianceId !== 0) {
      writer.uint32(16).int32(message.allianceId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AllianceExtensionUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllianceExtensionUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.allianceId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllianceExtensionUpdate {
    return {
      playerId: isSet(object.playerId)
        ? globalThis.String(object.playerId)
        : "",
      allianceId: isSet(object.allianceId)
        ? globalThis.Number(object.allianceId)
        : 0,
    };
  },

  toJSON(message: AllianceExtensionUpdate): unknown {
    const obj: any = {};
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    if (message.allianceId !== 0) {
      obj.allianceId = Math.round(message.allianceId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllianceExtensionUpdate>, I>>(
    base?: I,
  ): AllianceExtensionUpdate {
    return AllianceExtensionUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllianceExtensionUpdate>, I>>(
    object: I,
  ): AllianceExtensionUpdate {
    const message = createBaseAllianceExtensionUpdate();
    message.playerId = object.playerId ?? "";
    message.allianceId = object.allianceId ?? 0;
    return message;
  },
};

function createBaseTargetPlayerUpdate(): TargetPlayerUpdate {
  return { playerId: 0, targetId: 0 };
}

export const TargetPlayerUpdate: MessageFns<TargetPlayerUpdate> = {
  encode(
    message: TargetPlayerUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.playerId !== 0) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.targetId !== 0) {
      writer.uint32(16).int32(message.targetId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): TargetPlayerUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetPlayerUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.targetId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetPlayerUpdate {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : 0,
      targetId: isSet(object.targetId) ? globalThis.Number(object.targetId) : 0,
    };
  },

  toJSON(message: TargetPlayerUpdate): unknown {
    const obj: any = {};
    if (message.playerId !== 0) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.targetId !== 0) {
      obj.targetId = Math.round(message.targetId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TargetPlayerUpdate>, I>>(
    base?: I,
  ): TargetPlayerUpdate {
    return TargetPlayerUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TargetPlayerUpdate>, I>>(
    object: I,
  ): TargetPlayerUpdate {
    const message = createBaseTargetPlayerUpdate();
    message.playerId = object.playerId ?? 0;
    message.targetId = object.targetId ?? 0;
    return message;
  },
};

function createBaseEmojiUpdate(): EmojiUpdate {
  return { emoji: undefined };
}

export const EmojiUpdate: MessageFns<EmojiUpdate> = {
  encode(
    message: EmojiUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.emoji !== undefined) {
      EmojiMessage.encode(message.emoji, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmojiUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmojiUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.emoji = EmojiMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmojiUpdate {
    return {
      emoji: isSet(object.emoji)
        ? EmojiMessage.fromJSON(object.emoji)
        : undefined,
    };
  },

  toJSON(message: EmojiUpdate): unknown {
    const obj: any = {};
    if (message.emoji !== undefined) {
      obj.emoji = EmojiMessage.toJSON(message.emoji);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmojiUpdate>, I>>(base?: I): EmojiUpdate {
    return EmojiUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmojiUpdate>, I>>(
    object: I,
  ): EmojiUpdate {
    const message = createBaseEmojiUpdate();
    message.emoji =
      object.emoji !== undefined && object.emoji !== null
        ? EmojiMessage.fromPartial(object.emoji)
        : undefined;
    return message;
  },
};

function createBaseDisplayMessageUpdate(): DisplayMessageUpdate {
  return {
    message: "",
    messageType: 0,
    goldAmount: undefined,
    playerId: undefined,
    params: {},
  };
}

export const DisplayMessageUpdate: MessageFns<DisplayMessageUpdate> = {
  encode(
    message: DisplayMessageUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.messageType !== 0) {
      writer.uint32(16).int32(message.messageType);
    }
    if (message.goldAmount !== undefined) {
      writer.uint32(24).int64(message.goldAmount);
    }
    if (message.playerId !== undefined) {
      writer.uint32(32).int64(message.playerId);
    }
    Object.entries(message.params).forEach(([key, value]) => {
      DisplayMessageUpdate_ParamsEntry.encode(
        { key: key as any, value },
        writer.uint32(42).fork(),
      ).join();
    });
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DisplayMessageUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisplayMessageUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.goldAmount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.playerId = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = DisplayMessageUpdate_ParamsEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry5.value !== undefined) {
            message.params[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisplayMessageUpdate {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      messageType: isSet(object.messageType)
        ? messageTypeFromJSON(object.messageType)
        : 0,
      goldAmount: isSet(object.goldAmount)
        ? globalThis.Number(object.goldAmount)
        : undefined,
      playerId: isSet(object.playerId)
        ? globalThis.Number(object.playerId)
        : undefined,
      params: isObject(object.params)
        ? Object.entries(object.params).reduce<{ [key: string]: string }>(
            (acc, [key, value]) => {
              acc[key] = String(value);
              return acc;
            },
            {},
          )
        : {},
    };
  },

  toJSON(message: DisplayMessageUpdate): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.messageType !== 0) {
      obj.messageType = messageTypeToJSON(message.messageType);
    }
    if (message.goldAmount !== undefined) {
      obj.goldAmount = Math.round(message.goldAmount);
    }
    if (message.playerId !== undefined) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.params) {
      const entries = Object.entries(message.params);
      if (entries.length > 0) {
        obj.params = {};
        entries.forEach(([k, v]) => {
          obj.params[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DisplayMessageUpdate>, I>>(
    base?: I,
  ): DisplayMessageUpdate {
    return DisplayMessageUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DisplayMessageUpdate>, I>>(
    object: I,
  ): DisplayMessageUpdate {
    const message = createBaseDisplayMessageUpdate();
    message.message = object.message ?? "";
    message.messageType = object.messageType ?? 0;
    message.goldAmount = object.goldAmount ?? undefined;
    message.playerId = object.playerId ?? undefined;
    message.params = Object.entries(object.params ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseDisplayMessageUpdate_ParamsEntry(): DisplayMessageUpdate_ParamsEntry {
  return { key: "", value: "" };
}

export const DisplayMessageUpdate_ParamsEntry: MessageFns<DisplayMessageUpdate_ParamsEntry> =
  {
    encode(
      message: DisplayMessageUpdate_ParamsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== "") {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): DisplayMessageUpdate_ParamsEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseDisplayMessageUpdate_ParamsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): DisplayMessageUpdate_ParamsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? globalThis.String(object.value) : "",
      };
    },

    toJSON(message: DisplayMessageUpdate_ParamsEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== "") {
        obj.value = message.value;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<DisplayMessageUpdate_ParamsEntry>, I>>(
      base?: I,
    ): DisplayMessageUpdate_ParamsEntry {
      return DisplayMessageUpdate_ParamsEntry.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<DisplayMessageUpdate_ParamsEntry>, I>,
    >(object: I): DisplayMessageUpdate_ParamsEntry {
      const message = createBaseDisplayMessageUpdate_ParamsEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? "";
      return message;
    },
  };

function createBaseDisplayChatMessageUpdate(): DisplayChatMessageUpdate {
  return {
    key: "",
    category: "",
    target: undefined,
    playerId: undefined,
    isFrom: false,
    recipient: "",
  };
}

export const DisplayChatMessageUpdate: MessageFns<DisplayChatMessageUpdate> = {
  encode(
    message: DisplayChatMessageUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.category !== "") {
      writer.uint32(18).string(message.category);
    }
    if (message.target !== undefined) {
      writer.uint32(26).string(message.target);
    }
    if (message.playerId !== undefined) {
      writer.uint32(32).int32(message.playerId);
    }
    if (message.isFrom !== false) {
      writer.uint32(40).bool(message.isFrom);
    }
    if (message.recipient !== "") {
      writer.uint32(50).string(message.recipient);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DisplayChatMessageUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisplayChatMessageUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isFrom = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.recipient = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisplayChatMessageUpdate {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      category: isSet(object.category)
        ? globalThis.String(object.category)
        : "",
      target: isSet(object.target)
        ? globalThis.String(object.target)
        : undefined,
      playerId: isSet(object.playerId)
        ? globalThis.Number(object.playerId)
        : undefined,
      isFrom: isSet(object.isFrom) ? globalThis.Boolean(object.isFrom) : false,
      recipient: isSet(object.recipient)
        ? globalThis.String(object.recipient)
        : "",
    };
  },

  toJSON(message: DisplayChatMessageUpdate): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.target !== undefined) {
      obj.target = message.target;
    }
    if (message.playerId !== undefined) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.isFrom !== false) {
      obj.isFrom = message.isFrom;
    }
    if (message.recipient !== "") {
      obj.recipient = message.recipient;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DisplayChatMessageUpdate>, I>>(
    base?: I,
  ): DisplayChatMessageUpdate {
    return DisplayChatMessageUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DisplayChatMessageUpdate>, I>>(
    object: I,
  ): DisplayChatMessageUpdate {
    const message = createBaseDisplayChatMessageUpdate();
    message.key = object.key ?? "";
    message.category = object.category ?? "";
    message.target = object.target ?? undefined;
    message.playerId = object.playerId ?? undefined;
    message.isFrom = object.isFrom ?? false;
    message.recipient = object.recipient ?? "";
    return message;
  },
};

function createBaseWinUpdate(): WinUpdate {
  return { winner: "", stats: "" };
}

export const WinUpdate: MessageFns<WinUpdate> = {
  encode(
    message: WinUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.winner !== "") {
      writer.uint32(10).string(message.winner);
    }
    if (message.stats !== "") {
      writer.uint32(18).string(message.stats);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WinUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWinUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.winner = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stats = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WinUpdate {
    return {
      winner: isSet(object.winner) ? globalThis.String(object.winner) : "",
      stats: isSet(object.stats) ? globalThis.String(object.stats) : "",
    };
  },

  toJSON(message: WinUpdate): unknown {
    const obj: any = {};
    if (message.winner !== "") {
      obj.winner = message.winner;
    }
    if (message.stats !== "") {
      obj.stats = message.stats;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WinUpdate>, I>>(base?: I): WinUpdate {
    return WinUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WinUpdate>, I>>(
    object: I,
  ): WinUpdate {
    const message = createBaseWinUpdate();
    message.winner = object.winner ?? "";
    message.stats = object.stats ?? "";
    return message;
  },
};

function createBaseHashUpdate(): HashUpdate {
  return { tick: 0, hash: 0 };
}

export const HashUpdate: MessageFns<HashUpdate> = {
  encode(
    message: HashUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.tick !== 0) {
      writer.uint32(8).int32(message.tick);
    }
    if (message.hash !== 0) {
      writer.uint32(16).int32(message.hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HashUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHashUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tick = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hash = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HashUpdate {
    return {
      tick: isSet(object.tick) ? globalThis.Number(object.tick) : 0,
      hash: isSet(object.hash) ? globalThis.Number(object.hash) : 0,
    };
  },

  toJSON(message: HashUpdate): unknown {
    const obj: any = {};
    if (message.tick !== 0) {
      obj.tick = Math.round(message.tick);
    }
    if (message.hash !== 0) {
      obj.hash = Math.round(message.hash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HashUpdate>, I>>(base?: I): HashUpdate {
    return HashUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HashUpdate>, I>>(
    object: I,
  ): HashUpdate {
    const message = createBaseHashUpdate();
    message.tick = object.tick ?? 0;
    message.hash = object.hash ?? 0;
    return message;
  },
};

function createBaseUnitIncomingUpdate(): UnitIncomingUpdate {
  return { unitId: 0, message: "", messageType: 0, playerId: 0 };
}

export const UnitIncomingUpdate: MessageFns<UnitIncomingUpdate> = {
  encode(
    message: UnitIncomingUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.unitId !== 0) {
      writer.uint32(8).int32(message.unitId);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.messageType !== 0) {
      writer.uint32(24).int32(message.messageType);
    }
    if (message.playerId !== 0) {
      writer.uint32(32).int32(message.playerId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): UnitIncomingUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnitIncomingUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.unitId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnitIncomingUpdate {
    return {
      unitId: isSet(object.unitId) ? globalThis.Number(object.unitId) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      messageType: isSet(object.messageType)
        ? messageTypeFromJSON(object.messageType)
        : 0,
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : 0,
    };
  },

  toJSON(message: UnitIncomingUpdate): unknown {
    const obj: any = {};
    if (message.unitId !== 0) {
      obj.unitId = Math.round(message.unitId);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.messageType !== 0) {
      obj.messageType = messageTypeToJSON(message.messageType);
    }
    if (message.playerId !== 0) {
      obj.playerId = Math.round(message.playerId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnitIncomingUpdate>, I>>(
    base?: I,
  ): UnitIncomingUpdate {
    return UnitIncomingUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnitIncomingUpdate>, I>>(
    object: I,
  ): UnitIncomingUpdate {
    const message = createBaseUnitIncomingUpdate();
    message.unitId = object.unitId ?? 0;
    message.message = object.message ?? "";
    message.messageType = object.messageType ?? 0;
    message.playerId = object.playerId ?? 0;
    return message;
  },
};

function createBaseEmbargoUpdate(): EmbargoUpdate {
  return { event: 0, playerId: 0, embargoedId: 0 };
}

export const EmbargoUpdate: MessageFns<EmbargoUpdate> = {
  encode(
    message: EmbargoUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.event !== 0) {
      writer.uint32(8).int32(message.event);
    }
    if (message.playerId !== 0) {
      writer.uint32(16).int32(message.playerId);
    }
    if (message.embargoedId !== 0) {
      writer.uint32(24).int32(message.embargoedId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbargoUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbargoUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.event = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.embargoedId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbargoUpdate {
    return {
      event: isSet(object.event)
        ? embargoUpdate_EmbargoEventFromJSON(object.event)
        : 0,
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : 0,
      embargoedId: isSet(object.embargoedId)
        ? globalThis.Number(object.embargoedId)
        : 0,
    };
  },

  toJSON(message: EmbargoUpdate): unknown {
    const obj: any = {};
    if (message.event !== 0) {
      obj.event = embargoUpdate_EmbargoEventToJSON(message.event);
    }
    if (message.playerId !== 0) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.embargoedId !== 0) {
      obj.embargoedId = Math.round(message.embargoedId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmbargoUpdate>, I>>(
    base?: I,
  ): EmbargoUpdate {
    return EmbargoUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmbargoUpdate>, I>>(
    object: I,
  ): EmbargoUpdate {
    const message = createBaseEmbargoUpdate();
    message.event = object.event ?? 0;
    message.playerId = object.playerId ?? 0;
    message.embargoedId = object.embargoedId ?? 0;
    return message;
  },
};

function createBaseGameUpdate(): GameUpdate {
  return {
    type: 0,
    unit: undefined,
    player: undefined,
    allianceRequest: undefined,
    allianceRequestReply: undefined,
    brokeAlliance: undefined,
    allianceExpired: undefined,
    displayMessage: undefined,
    displayChatMessage: undefined,
    targetPlayer: undefined,
    emoji: undefined,
    win: undefined,
    hash: undefined,
    unitIncoming: undefined,
    allianceExtension: undefined,
    bonusEvent: undefined,
    railroad: undefined,
    conquest: undefined,
    embargo: undefined,
  };
}

export const GameUpdate: MessageFns<GameUpdate> = {
  encode(
    message: GameUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.unit !== undefined) {
      UnitUpdate.encode(message.unit, writer.uint32(26).fork()).join();
    }
    if (message.player !== undefined) {
      PlayerUpdate.encode(message.player, writer.uint32(34).fork()).join();
    }
    if (message.allianceRequest !== undefined) {
      AllianceRequestUpdate.encode(
        message.allianceRequest,
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.allianceRequestReply !== undefined) {
      AllianceRequestReplyUpdate.encode(
        message.allianceRequestReply,
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.brokeAlliance !== undefined) {
      BrokeAllianceUpdate.encode(
        message.brokeAlliance,
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.allianceExpired !== undefined) {
      AllianceExpiredUpdate.encode(
        message.allianceExpired,
        writer.uint32(66).fork(),
      ).join();
    }
    if (message.displayMessage !== undefined) {
      DisplayMessageUpdate.encode(
        message.displayMessage,
        writer.uint32(74).fork(),
      ).join();
    }
    if (message.displayChatMessage !== undefined) {
      DisplayChatMessageUpdate.encode(
        message.displayChatMessage,
        writer.uint32(82).fork(),
      ).join();
    }
    if (message.targetPlayer !== undefined) {
      TargetPlayerUpdate.encode(
        message.targetPlayer,
        writer.uint32(90).fork(),
      ).join();
    }
    if (message.emoji !== undefined) {
      EmojiUpdate.encode(message.emoji, writer.uint32(98).fork()).join();
    }
    if (message.win !== undefined) {
      WinUpdate.encode(message.win, writer.uint32(106).fork()).join();
    }
    if (message.hash !== undefined) {
      HashUpdate.encode(message.hash, writer.uint32(114).fork()).join();
    }
    if (message.unitIncoming !== undefined) {
      UnitIncomingUpdate.encode(
        message.unitIncoming,
        writer.uint32(122).fork(),
      ).join();
    }
    if (message.allianceExtension !== undefined) {
      AllianceExtensionUpdate.encode(
        message.allianceExtension,
        writer.uint32(130).fork(),
      ).join();
    }
    if (message.bonusEvent !== undefined) {
      BonusEventUpdate.encode(
        message.bonusEvent,
        writer.uint32(138).fork(),
      ).join();
    }
    if (message.railroad !== undefined) {
      RailroadUpdate.encode(message.railroad, writer.uint32(146).fork()).join();
    }
    if (message.conquest !== undefined) {
      ConquestUpdate.encode(message.conquest, writer.uint32(154).fork()).join();
    }
    if (message.embargo !== undefined) {
      EmbargoUpdate.encode(message.embargo, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.unit = UnitUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.player = PlayerUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.allianceRequest = AllianceRequestUpdate.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.allianceRequestReply = AllianceRequestReplyUpdate.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.brokeAlliance = BrokeAllianceUpdate.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.allianceExpired = AllianceExpiredUpdate.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.displayMessage = DisplayMessageUpdate.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.displayChatMessage = DisplayChatMessageUpdate.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.targetPlayer = TargetPlayerUpdate.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.emoji = EmojiUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.win = WinUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.hash = HashUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.unitIncoming = UnitIncomingUpdate.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.allianceExtension = AllianceExtensionUpdate.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.bonusEvent = BonusEventUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.railroad = RailroadUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.conquest = ConquestUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.embargo = EmbargoUpdate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameUpdate {
    return {
      type: isSet(object.type) ? gameUpdateTypeFromJSON(object.type) : 0,
      unit: isSet(object.unit) ? UnitUpdate.fromJSON(object.unit) : undefined,
      player: isSet(object.player)
        ? PlayerUpdate.fromJSON(object.player)
        : undefined,
      allianceRequest: isSet(object.allianceRequest)
        ? AllianceRequestUpdate.fromJSON(object.allianceRequest)
        : undefined,
      allianceRequestReply: isSet(object.allianceRequestReply)
        ? AllianceRequestReplyUpdate.fromJSON(object.allianceRequestReply)
        : undefined,
      brokeAlliance: isSet(object.brokeAlliance)
        ? BrokeAllianceUpdate.fromJSON(object.brokeAlliance)
        : undefined,
      allianceExpired: isSet(object.allianceExpired)
        ? AllianceExpiredUpdate.fromJSON(object.allianceExpired)
        : undefined,
      displayMessage: isSet(object.displayMessage)
        ? DisplayMessageUpdate.fromJSON(object.displayMessage)
        : undefined,
      displayChatMessage: isSet(object.displayChatMessage)
        ? DisplayChatMessageUpdate.fromJSON(object.displayChatMessage)
        : undefined,
      targetPlayer: isSet(object.targetPlayer)
        ? TargetPlayerUpdate.fromJSON(object.targetPlayer)
        : undefined,
      emoji: isSet(object.emoji)
        ? EmojiUpdate.fromJSON(object.emoji)
        : undefined,
      win: isSet(object.win) ? WinUpdate.fromJSON(object.win) : undefined,
      hash: isSet(object.hash) ? HashUpdate.fromJSON(object.hash) : undefined,
      unitIncoming: isSet(object.unitIncoming)
        ? UnitIncomingUpdate.fromJSON(object.unitIncoming)
        : undefined,
      allianceExtension: isSet(object.allianceExtension)
        ? AllianceExtensionUpdate.fromJSON(object.allianceExtension)
        : undefined,
      bonusEvent: isSet(object.bonusEvent)
        ? BonusEventUpdate.fromJSON(object.bonusEvent)
        : undefined,
      railroad: isSet(object.railroad)
        ? RailroadUpdate.fromJSON(object.railroad)
        : undefined,
      conquest: isSet(object.conquest)
        ? ConquestUpdate.fromJSON(object.conquest)
        : undefined,
      embargo: isSet(object.embargo)
        ? EmbargoUpdate.fromJSON(object.embargo)
        : undefined,
    };
  },

  toJSON(message: GameUpdate): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = gameUpdateTypeToJSON(message.type);
    }
    if (message.unit !== undefined) {
      obj.unit = UnitUpdate.toJSON(message.unit);
    }
    if (message.player !== undefined) {
      obj.player = PlayerUpdate.toJSON(message.player);
    }
    if (message.allianceRequest !== undefined) {
      obj.allianceRequest = AllianceRequestUpdate.toJSON(
        message.allianceRequest,
      );
    }
    if (message.allianceRequestReply !== undefined) {
      obj.allianceRequestReply = AllianceRequestReplyUpdate.toJSON(
        message.allianceRequestReply,
      );
    }
    if (message.brokeAlliance !== undefined) {
      obj.brokeAlliance = BrokeAllianceUpdate.toJSON(message.brokeAlliance);
    }
    if (message.allianceExpired !== undefined) {
      obj.allianceExpired = AllianceExpiredUpdate.toJSON(
        message.allianceExpired,
      );
    }
    if (message.displayMessage !== undefined) {
      obj.displayMessage = DisplayMessageUpdate.toJSON(message.displayMessage);
    }
    if (message.displayChatMessage !== undefined) {
      obj.displayChatMessage = DisplayChatMessageUpdate.toJSON(
        message.displayChatMessage,
      );
    }
    if (message.targetPlayer !== undefined) {
      obj.targetPlayer = TargetPlayerUpdate.toJSON(message.targetPlayer);
    }
    if (message.emoji !== undefined) {
      obj.emoji = EmojiUpdate.toJSON(message.emoji);
    }
    if (message.win !== undefined) {
      obj.win = WinUpdate.toJSON(message.win);
    }
    if (message.hash !== undefined) {
      obj.hash = HashUpdate.toJSON(message.hash);
    }
    if (message.unitIncoming !== undefined) {
      obj.unitIncoming = UnitIncomingUpdate.toJSON(message.unitIncoming);
    }
    if (message.allianceExtension !== undefined) {
      obj.allianceExtension = AllianceExtensionUpdate.toJSON(
        message.allianceExtension,
      );
    }
    if (message.bonusEvent !== undefined) {
      obj.bonusEvent = BonusEventUpdate.toJSON(message.bonusEvent);
    }
    if (message.railroad !== undefined) {
      obj.railroad = RailroadUpdate.toJSON(message.railroad);
    }
    if (message.conquest !== undefined) {
      obj.conquest = ConquestUpdate.toJSON(message.conquest);
    }
    if (message.embargo !== undefined) {
      obj.embargo = EmbargoUpdate.toJSON(message.embargo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameUpdate>, I>>(base?: I): GameUpdate {
    return GameUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameUpdate>, I>>(
    object: I,
  ): GameUpdate {
    const message = createBaseGameUpdate();
    message.type = object.type ?? 0;
    message.unit =
      object.unit !== undefined && object.unit !== null
        ? UnitUpdate.fromPartial(object.unit)
        : undefined;
    message.player =
      object.player !== undefined && object.player !== null
        ? PlayerUpdate.fromPartial(object.player)
        : undefined;
    message.allianceRequest =
      object.allianceRequest !== undefined && object.allianceRequest !== null
        ? AllianceRequestUpdate.fromPartial(object.allianceRequest)
        : undefined;
    message.allianceRequestReply =
      object.allianceRequestReply !== undefined &&
      object.allianceRequestReply !== null
        ? AllianceRequestReplyUpdate.fromPartial(object.allianceRequestReply)
        : undefined;
    message.brokeAlliance =
      object.brokeAlliance !== undefined && object.brokeAlliance !== null
        ? BrokeAllianceUpdate.fromPartial(object.brokeAlliance)
        : undefined;
    message.allianceExpired =
      object.allianceExpired !== undefined && object.allianceExpired !== null
        ? AllianceExpiredUpdate.fromPartial(object.allianceExpired)
        : undefined;
    message.displayMessage =
      object.displayMessage !== undefined && object.displayMessage !== null
        ? DisplayMessageUpdate.fromPartial(object.displayMessage)
        : undefined;
    message.displayChatMessage =
      object.displayChatMessage !== undefined &&
      object.displayChatMessage !== null
        ? DisplayChatMessageUpdate.fromPartial(object.displayChatMessage)
        : undefined;
    message.targetPlayer =
      object.targetPlayer !== undefined && object.targetPlayer !== null
        ? TargetPlayerUpdate.fromPartial(object.targetPlayer)
        : undefined;
    message.emoji =
      object.emoji !== undefined && object.emoji !== null
        ? EmojiUpdate.fromPartial(object.emoji)
        : undefined;
    message.win =
      object.win !== undefined && object.win !== null
        ? WinUpdate.fromPartial(object.win)
        : undefined;
    message.hash =
      object.hash !== undefined && object.hash !== null
        ? HashUpdate.fromPartial(object.hash)
        : undefined;
    message.unitIncoming =
      object.unitIncoming !== undefined && object.unitIncoming !== null
        ? UnitIncomingUpdate.fromPartial(object.unitIncoming)
        : undefined;
    message.allianceExtension =
      object.allianceExtension !== undefined &&
      object.allianceExtension !== null
        ? AllianceExtensionUpdate.fromPartial(object.allianceExtension)
        : undefined;
    message.bonusEvent =
      object.bonusEvent !== undefined && object.bonusEvent !== null
        ? BonusEventUpdate.fromPartial(object.bonusEvent)
        : undefined;
    message.railroad =
      object.railroad !== undefined && object.railroad !== null
        ? RailroadUpdate.fromPartial(object.railroad)
        : undefined;
    message.conquest =
      object.conquest !== undefined && object.conquest !== null
        ? ConquestUpdate.fromPartial(object.conquest)
        : undefined;
    message.embargo =
      object.embargo !== undefined && object.embargo !== null
        ? EmbargoUpdate.fromPartial(object.embargo)
        : undefined;
    return message;
  },
};

function createBaseGameUpdates(): GameUpdates {
  return { type: 0, updates: [] };
}

export const GameUpdates: MessageFns<GameUpdates> = {
  encode(
    message: GameUpdates,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.updates) {
      GameUpdate.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameUpdates {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameUpdates();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updates.push(GameUpdate.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameUpdates {
    return {
      type: isSet(object.type) ? gameUpdateTypeFromJSON(object.type) : 0,
      updates: globalThis.Array.isArray(object?.updates)
        ? object.updates.map((e: any) => GameUpdate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GameUpdates): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = gameUpdateTypeToJSON(message.type);
    }
    if (message.updates?.length) {
      obj.updates = message.updates.map((e) => GameUpdate.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameUpdates>, I>>(base?: I): GameUpdates {
    return GameUpdates.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameUpdates>, I>>(
    object: I,
  ): GameUpdates {
    const message = createBaseGameUpdates();
    message.type = object.type ?? 0;
    message.updates =
      object.updates?.map((e) => GameUpdate.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGameUpdateViewData(): GameUpdateViewData {
  return {
    tick: 0,
    updates: {},
    tileUpdates: [],
    playerNameViewData: {},
    tickExecutionDuration: undefined,
  };
}

export const GameUpdateViewData: MessageFns<GameUpdateViewData> = {
  encode(
    message: GameUpdateViewData,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.tick !== 0) {
      writer.uint32(8).int32(message.tick);
    }
    Object.entries(message.updates).forEach(([key, value]) => {
      GameUpdateViewData_UpdatesEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork(),
      ).join();
    });
    writer.uint32(26).fork();
    for (const v of message.tileUpdates) {
      writer.int64(v);
    }
    writer.join();
    Object.entries(message.playerNameViewData).forEach(([key, value]) => {
      GameUpdateViewData_PlayerNameViewDataEntry.encode(
        { key: key as any, value },
        writer.uint32(34).fork(),
      ).join();
    });
    if (message.tickExecutionDuration !== undefined) {
      writer.uint32(41).double(message.tickExecutionDuration);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GameUpdateViewData {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameUpdateViewData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tick = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = GameUpdateViewData_UpdatesEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry2.value !== undefined) {
            message.updates[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.tileUpdates.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.tileUpdates.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = GameUpdateViewData_PlayerNameViewDataEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry4.value !== undefined) {
            message.playerNameViewData[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.tickExecutionDuration = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameUpdateViewData {
    return {
      tick: isSet(object.tick) ? globalThis.Number(object.tick) : 0,
      updates: isObject(object.updates)
        ? Object.entries(object.updates).reduce<{ [key: number]: GameUpdates }>(
            (acc, [key, value]) => {
              acc[globalThis.Number(key)] = GameUpdates.fromJSON(value);
              return acc;
            },
            {},
          )
        : {},
      tileUpdates: globalThis.Array.isArray(object?.tileUpdates)
        ? object.tileUpdates.map((e: any) => globalThis.Number(e))
        : [],
      playerNameViewData: isObject(object.playerNameViewData)
        ? Object.entries(object.playerNameViewData).reduce<{
            [key: string]: NameViewData;
          }>((acc, [key, value]) => {
            acc[key] = NameViewData.fromJSON(value);
            return acc;
          }, {})
        : {},
      tickExecutionDuration: isSet(object.tickExecutionDuration)
        ? globalThis.Number(object.tickExecutionDuration)
        : undefined,
    };
  },

  toJSON(message: GameUpdateViewData): unknown {
    const obj: any = {};
    if (message.tick !== 0) {
      obj.tick = Math.round(message.tick);
    }
    if (message.updates) {
      const entries = Object.entries(message.updates);
      if (entries.length > 0) {
        obj.updates = {};
        entries.forEach(([k, v]) => {
          obj.updates[k] = GameUpdates.toJSON(v);
        });
      }
    }
    if (message.tileUpdates?.length) {
      obj.tileUpdates = message.tileUpdates.map((e) => Math.round(e));
    }
    if (message.playerNameViewData) {
      const entries = Object.entries(message.playerNameViewData);
      if (entries.length > 0) {
        obj.playerNameViewData = {};
        entries.forEach(([k, v]) => {
          obj.playerNameViewData[k] = NameViewData.toJSON(v);
        });
      }
    }
    if (message.tickExecutionDuration !== undefined) {
      obj.tickExecutionDuration = message.tickExecutionDuration;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameUpdateViewData>, I>>(
    base?: I,
  ): GameUpdateViewData {
    return GameUpdateViewData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameUpdateViewData>, I>>(
    object: I,
  ): GameUpdateViewData {
    const message = createBaseGameUpdateViewData();
    message.tick = object.tick ?? 0;
    message.updates = Object.entries(object.updates ?? {}).reduce<{
      [key: number]: GameUpdates;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[globalThis.Number(key)] = GameUpdates.fromPartial(value);
      }
      return acc;
    }, {});
    message.tileUpdates = object.tileUpdates?.map((e) => e) || [];
    message.playerNameViewData = Object.entries(
      object.playerNameViewData ?? {},
    ).reduce<{ [key: string]: NameViewData }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = NameViewData.fromPartial(value);
      }
      return acc;
    }, {});
    message.tickExecutionDuration = object.tickExecutionDuration ?? undefined;
    return message;
  },
};

function createBaseGameUpdateViewData_UpdatesEntry(): GameUpdateViewData_UpdatesEntry {
  return { key: 0, value: undefined };
}

export const GameUpdateViewData_UpdatesEntry: MessageFns<GameUpdateViewData_UpdatesEntry> =
  {
    encode(
      message: GameUpdateViewData_UpdatesEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== 0) {
        writer.uint32(8).int32(message.key);
      }
      if (message.value !== undefined) {
        GameUpdates.encode(message.value, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GameUpdateViewData_UpdatesEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGameUpdateViewData_UpdatesEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.key = reader.int32();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = GameUpdates.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GameUpdateViewData_UpdatesEntry {
      return {
        key: isSet(object.key) ? globalThis.Number(object.key) : 0,
        value: isSet(object.value)
          ? GameUpdates.fromJSON(object.value)
          : undefined,
      };
    },

    toJSON(message: GameUpdateViewData_UpdatesEntry): unknown {
      const obj: any = {};
      if (message.key !== 0) {
        obj.key = Math.round(message.key);
      }
      if (message.value !== undefined) {
        obj.value = GameUpdates.toJSON(message.value);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GameUpdateViewData_UpdatesEntry>, I>>(
      base?: I,
    ): GameUpdateViewData_UpdatesEntry {
      return GameUpdateViewData_UpdatesEntry.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<GameUpdateViewData_UpdatesEntry>, I>,
    >(object: I): GameUpdateViewData_UpdatesEntry {
      const message = createBaseGameUpdateViewData_UpdatesEntry();
      message.key = object.key ?? 0;
      message.value =
        object.value !== undefined && object.value !== null
          ? GameUpdates.fromPartial(object.value)
          : undefined;
      return message;
    },
  };

function createBaseGameUpdateViewData_PlayerNameViewDataEntry(): GameUpdateViewData_PlayerNameViewDataEntry {
  return { key: "", value: undefined };
}

export const GameUpdateViewData_PlayerNameViewDataEntry: MessageFns<GameUpdateViewData_PlayerNameViewDataEntry> =
  {
    encode(
      message: GameUpdateViewData_PlayerNameViewDataEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        NameViewData.encode(message.value, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GameUpdateViewData_PlayerNameViewDataEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGameUpdateViewData_PlayerNameViewDataEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = NameViewData.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GameUpdateViewData_PlayerNameViewDataEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value)
          ? NameViewData.fromJSON(object.value)
          : undefined,
      };
    },

    toJSON(message: GameUpdateViewData_PlayerNameViewDataEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== undefined) {
        obj.value = NameViewData.toJSON(message.value);
      }
      return obj;
    },

    create<
      I extends Exact<
        DeepPartial<GameUpdateViewData_PlayerNameViewDataEntry>,
        I
      >,
    >(base?: I): GameUpdateViewData_PlayerNameViewDataEntry {
      return GameUpdateViewData_PlayerNameViewDataEntry.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<
        DeepPartial<GameUpdateViewData_PlayerNameViewDataEntry>,
        I
      >,
    >(object: I): GameUpdateViewData_PlayerNameViewDataEntry {
      const message = createBaseGameUpdateViewData_PlayerNameViewDataEntry();
      message.key = object.key ?? "";
      message.value =
        object.value !== undefined && object.value !== null
          ? NameViewData.fromPartial(object.value)
          : undefined;
      return message;
    },
  };

function createBaseErrorUpdate(): ErrorUpdate {
  return { errMsg: "", stack: undefined };
}

export const ErrorUpdate: MessageFns<ErrorUpdate> = {
  encode(
    message: ErrorUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errMsg !== "") {
      writer.uint32(10).string(message.errMsg);
    }
    if (message.stack !== undefined) {
      writer.uint32(18).string(message.stack);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorUpdate {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errMsg = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stack = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorUpdate {
    return {
      errMsg: isSet(object.errMsg) ? globalThis.String(object.errMsg) : "",
      stack: isSet(object.stack) ? globalThis.String(object.stack) : undefined,
    };
  },

  toJSON(message: ErrorUpdate): unknown {
    const obj: any = {};
    if (message.errMsg !== "") {
      obj.errMsg = message.errMsg;
    }
    if (message.stack !== undefined) {
      obj.stack = message.stack;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorUpdate>, I>>(base?: I): ErrorUpdate {
    return ErrorUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorUpdate>, I>>(
    object: I,
  ): ErrorUpdate {
    const message = createBaseErrorUpdate();
    message.errMsg = object.errMsg ?? "";
    message.stack = object.stack ?? undefined;
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
