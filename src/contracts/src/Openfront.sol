// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title Openfront Game Contract
 * @dev Handles on-chain betting and prize distribution for Openfront games
 */
contract Openfront is ReentrancyGuard {
    error LobbyNotFound();
    error NotHost();
    error NotWinner();
    error NotGameServer();
    error InvalidBetAmount();
    error LobbyFull();
    error GameAlreadyStarted();
    error GameNotFinished();
    error PrizeAlreadyClaimed();
    error NotParticipant();
    error InsufficientFunds();

    struct Lobby {
        address host;               // Address that created and owns the lobby
        uint256 betAmount;          // The ETH amount each player must pay/bet to join
        address[] participants;     // Array of participant addresses
        GameStatus status;          // Current game state
        address winner;             // Winner address (set by game server)
        uint256 totalPrize;         // Total prize pool for this lobby
    }
    
    enum GameStatus { 
        Created,     // Lobby exists, players can join
        InProgress,  // Game has started, no new joins allowed
        Finished,    // Winner declared by game server
        Claimed      // Prize has been withdrawn
    }
    
    // State variables
    mapping(bytes32 => Lobby) public publicLobbies;
    mapping(bytes32 => Lobby) public privateLobbies;
    mapping(bytes32 => Lobby) public lobbies;
    bytes32[] public publicLobbyIds;    // Array to track public lobby IDs
    bytes32[] public privateLobbyIds;   // Array to track private lobby IDs
    address public gameServer;          // Authorized address to declare winners
    address public owner;               // Contract owner
    
    // Events for frontend real-time updates
    event LobbyCreated(bytes32 indexed lobbyId, address indexed host, uint256 betAmount);
    event ParticipantJoined(bytes32 indexed lobbyId, address indexed participant);
    event GameStarted(bytes32 indexed lobbyId);
    event GameFinished(bytes32 indexed lobbyId, address indexed winner);
    event PrizeClaimed(bytes32 indexed lobbyId, address indexed winner, uint256 amount);
    
    modifier onlyHost(bytes32 lobbyId) {
        if (lobbies[lobbyId].host != msg.sender) revert NotHost();
        _;
    }
    
    modifier onlyGameServer() {
        if (msg.sender != gameServer) revert NotGameServer();
        _;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    modifier lobbyExists(bytes32 lobbyId) {
        if (lobbies[lobbyId].host == address(0)) revert LobbyNotFound();
        _;
    }

    constructor(address _gameServer) {
        owner = msg.sender;
        gameServer = _gameServer;
    }
    
    /**
     * @dev Creates a new game lobby with specified bet amount
     * @param lobbyId Unique identifier for the lobby (generated by frontend)
     * @param betAmount Amount of ETH each player must bet to join
     */
    function createLobby(bytes32 lobbyId, uint256 betAmount, bool isPublic) external payable nonReentrant {
        if (betAmount == 0) revert InvalidBetAmount();
        if (msg.value != betAmount) revert InsufficientFunds();
        if (lobbies[lobbyId].host != address(0)) revert();  // Lobby already exists
        
        // Create a new lobby
        if (isPublic) {
          publicLobbies[lobbyId] = Lobby({
            host: msg.sender,
            betAmount: betAmount,
            participants: new address[](0),
            status: GameStatus.Created,
            winner: address(0),
            totalPrize: betAmount
          });
          publicLobbyIds.push(lobbyId);
          lobbies[lobbyId] = Lobby({
            host: msg.sender,
            betAmount: betAmount,
            participants: new address[](0),
            status: GameStatus.Created,
            winner: address(0),
            totalPrize: betAmount
          });
        } else {
          privateLobbies[lobbyId] = Lobby({
            host: msg.sender,
            betAmount: betAmount,
            participants: new address[](0),
            status: GameStatus.Created,
            winner: address(0),
            totalPrize: betAmount
          });
          privateLobbyIds.push(lobbyId);
          lobbies[lobbyId] = Lobby({
            host: msg.sender,
            betAmount: betAmount,
            participants: new address[](0),
            status: GameStatus.Created,
            winner: address(0),
            totalPrize: betAmount
          });
        }
        Openfront
        // Host automatically joins as first participant
        lobbies[lobbyId].participants.push(msg.sender);
        
        emit LobbyCreated(lobbyId, msg.sender, betAmount);
        emit ParticipantJoined(lobbyId, msg.sender);
    }
    
    /**
     * @dev Allows players to join an existing lobby by paying the bet amount
     * @param lobbyId The lobby to join
     */
    function joinLobby(bytes32 lobbyId) external payable nonReentrant lobbyExists(lobbyId) {
        Lobby storage lobby = lobbies[lobbyId];
        
        if (lobby.status != GameStatus.Created) revert GameAlreadyStarted();
        if (msg.value != lobby.betAmount) revert InsufficientFunds();
        
        // Check if already a participant
        for (uint256 i = 0; i < lobby.participants.length; i++) {
            if (lobby.participants[i] == msg.sender) {
                revert(); // Already joined
            }
        }
        
        // Add participant
        lobby.participants.push(msg.sender);
        lobby.totalPrize += msg.value;
        
        emit ParticipantJoined(lobbyId, msg.sender);
    }
    
    /**
     * @dev Host starts the game, preventing new players from joining
     * @param lobbyId The lobby to start
     */
    function startGame(bytes32 lobbyId) external onlyHost(lobbyId) lobbyExists(lobbyId) {
        Lobby storage lobby = lobbies[lobbyId];
        
        if (lobby.status != GameStatus.Created) revert GameAlreadyStarted();
        if (lobby.participants.length < 2) revert(); // Need at least 2 players
        
        lobby.status = GameStatus.InProgress;
        
        emit GameStarted(lobbyId);
    }
    
    /**
     * @dev Game server declares the winner of a finished game
     * @param lobbyId The lobby that finished
     * @param winner Address of the winning player
     */
    function declareWinner(bytes32 lobbyId, address winner) external onlyGameServer lobbyExists(lobbyId) {
        Lobby storage lobby = lobbies[lobbyId];
        
        if (lobby.status != GameStatus.InProgress) revert();
        
        // Verify winner is a participant
        bool validParticipant = false;
        for (uint256 i = 0; i < lobby.participants.length; i++) {
            if (lobby.participants[i] == winner) {
                validParticipant = true;
                break;
            }
        }
        if (!validParticipant) revert NotParticipant();
        
        lobby.winner = winner;
        lobby.status = GameStatus.Finished;
        
        emit GameFinished(lobbyId, winner);
    }
    
    /**
     * @dev Winner claims their prize from the completed game
     * @param lobbyId The lobby to claim prize from
     */
    function claimPrize(bytes32 lobbyId) external nonReentrant lobbyExists(lobbyId) {
        Lobby storage lobby = lobbies[lobbyId];
        
        if (lobby.status != GameStatus.Finished) revert GameNotFinished();
        if (lobby.winner != msg.sender) revert NotWinner();
        
        uint256 totalPrize = lobby.totalPrize;
        uint256 winnerPrize = totalPrize;
        
        lobby.status = GameStatus.Claimed;
        
        // Transfer prize to winner
        (bool success, ) = payable(msg.sender).call{value: winnerPrize}("");
        require(success, "Transfer failed");
        
        emit PrizeClaimed(lobbyId, msg.sender, winnerPrize);
    }
    
    /**
     * @dev Get lobby details
     * @param lobbyId The lobby to query
     */
    function getLobby(bytes32 lobbyId) external view returns (
        address host,
        uint256 betAmount,
        address[] memory participants,
        GameStatus status,
        address winner,
        uint256 totalPrize
    ) {
        Lobby memory lobby = lobbies[lobbyId];
        return (
            lobby.host,
            lobby.betAmount,
            lobby.participants,
            lobby.status,
            lobby.winner,
            lobby.totalPrize
        );
    }
    
    /**
     * @dev Get number of participants in a lobby
     * @param lobbyId The lobby to query
     */
    function getParticipantCount(bytes32 lobbyId) external view returns (uint256) {
        return lobbies[lobbyId].participants.length;
    }
    
    /**
     * @dev Check if an address is a participant in a lobby
     * @param lobbyId The lobby to check
     * @param participant The address to check
     */
    function isParticipant(bytes32 lobbyId, address participant) external view returns (bool) {
        address[] memory participants = lobbies[lobbyId].participants;
        for (uint256 i = 0; i < participants.length; i++) {
            if (participants[i] == participant) {
                return true;
            }
        }
        return false;
    }
    
    // Set who owns this contract
    // FIXME: only use in development!
    function setGameServer(address _gameServer) external onlyOwner {
        gameServer = _gameServer;
    }
    
    /**
     * @dev Get all public lobby IDs
     * @return Array of public lobby IDs
     */
    function getAllPublicLobbies() external view returns (bytes32[] memory) {
        return publicLobbyIds;
    }
    
    /**
     * @dev Get all private lobby IDs
     * @return Array of private lobby IDs
     */
    function getAllPrivateLobbies() external view returns (bytes32[] memory) {
        return privateLobbyIds;
    }
    
    /**
     * @dev Get public lobbies with pagination
     * @param offset Starting index
     * @param limit Maximum number of lobbies to return
     * @return Array of public lobby IDs
     */
    function getPublicLobbies(uint256 offset, uint256 limit) external view returns (bytes32[] memory) {
        if (offset >= publicLobbyIds.length) {
            return new bytes32[](0);
        }
        
        uint256 end = offset + limit;
        if (end > publicLobbyIds.length) {
            end = publicLobbyIds.length;
        }
        
        bytes32[] memory result = new bytes32[](end - offset);
        for (uint256 i = offset; i < end; i++) {
            result[i - offset] = publicLobbyIds[i];
        }
        
        return result;
    }
    
    /**
     * @dev Get private lobbies with pagination
     * @param offset Starting index
     * @param limit Maximum number of lobbies to return
     * @return Array of private lobby IDs
     */
    function getPrivateLobbies(uint256 offset, uint256 limit) external view returns (bytes32[] memory) {
        if (offset >= privateLobbyIds.length) {
            return new bytes32[](0);
        }
        
        uint256 end = offset + limit;
        if (end > privateLobbyIds.length) {
            end = privateLobbyIds.length;
        }
        
        bytes32[] memory result = new bytes32[](end - offset);
        for (uint256 i = offset; i < end; i++) {
            result[i - offset] = privateLobbyIds[i];
        }
        
        return result;
    }
    
    /**
     * @dev Get count of public lobbies
     * @return Number of public lobbies
     */
    function getPublicLobbyCount() external view returns (uint256) {
        return publicLobbyIds.length;
    }
    
    /**
     * @dev Get count of private lobbies
     * @return Number of private lobbies
     */
    function getPrivateLobbyCount() external view returns (uint256) {
        return privateLobbyIds.length;
    }
}
